{
version: 3,
file: "ZeroClipboard.min.js",
sources: [
"ZeroClipboard.js"
],
names: [
"window",
"undefined",
"_zcSwfVersion",
"_currentElement",
"_copyTarget",
"_window",
"_document",
"document",
"_navigator",
"navigator",
"_setTimeout",
"setTimeout",
"_clearTimeout",
"clearTimeout",
"_setInterval",
"setInterval",
"_clearInterval",
"clearInterval",
"_getComputedStyle",
"getComputedStyle",
"_encodeURIComponent",
"encodeURIComponent",
"_ActiveXObject",
"ActiveXObject",
"_Error",
"Error",
"_parseInt",
"Number",
"parseInt",
"_parseFloat",
"parseFloat",
"_isNaN",
"isNaN",
"_now",
"Date",
"now",
"_keys",
"Object",
"keys",
"_defineProperty",
"defineProperty",
"_hasOwn",
"prototype",
"hasOwnProperty",
"_slice",
"Array",
"slice",
"_unwrap",
"unwrapper",
"el",
"wrap",
"unwrap",
"div",
"createElement",
"unwrappedDiv",
"nodeType",
"e",
"_args",
"argumentsObj",
"call",
"_extend",
"i",
"len",
"arg",
"prop",
"src",
"copy",
"args",
"arguments",
"target",
"length",
"_deepCopy",
"source",
"_pick",
"obj",
"newObj",
"_omit",
"indexOf",
"_deleteOwnProperties",
"_containedBy",
"ancestorEl",
"ownerDocument",
"parentNode",
"_getDirPathOfUrl",
"url",
"dir",
"split",
"lastIndexOf",
"_getCurrentScriptUrlFromErrorStack",
"stack",
"matches",
"match",
"_getCurrentScriptUrlFromError",
"err",
"sourceURL",
"fileName",
"_getCurrentScriptUrl",
"jsPath",
"scripts",
"currentScript",
"getElementsByTagName",
"readyState",
"_getUnanimousScriptParentDir",
"jsDir",
"_getDefaultSwfPath",
"_isWindows",
"isWindowsRegex",
"test",
"appVersion",
"platform",
"userAgent",
"_pageIsFramed",
"opener",
"top",
"parent",
"_flashState",
"bridge",
"version",
"pluginType",
"disabled",
"outdated",
"sandboxed",
"unavailable",
"degraded",
"deactivated",
"overdue",
"ready",
"_minimumFlashVersion",
"_handlers",
"_clipData",
"_clipDataFormatMap",
"_flashCheckTimeout",
"_swfFallbackCheckInterval",
"_eventMessages",
"error",
"flash-disabled",
"flash-outdated",
"flash-sandboxed",
"flash-unavailable",
"flash-degraded",
"flash-deactivated",
"flash-overdue",
"version-mismatch",
"clipboard-error",
"config-mismatch",
"swf-not-found",
"_errorsThatOnlyOccurAfterFlashLoads",
"_flashStateErrorNames",
"_flashStateErrorNameMatchingRegex",
"RegExp",
"map",
"errorName",
"replace",
"join",
"_flashStateEnabledErrorNameMatchingRegex",
"_globalConfig",
"swfPath",
"trustedDomains",
"location",
"host",
"cacheBust",
"forceEnhancedClipboard",
"flashLoadTimeout",
"autoActivate",
"bubbleEvents",
"fixLineEndings",
"containerId",
"containerClass",
"swfObjectId",
"hoverClass",
"activeClass",
"forceHandCursor",
"title",
"zIndex",
"_config",
"options",
"_isValidHtml4Id",
"_state",
"_detectSandbox",
"browser",
"flash",
"zeroclipboard",
"ZeroClipboard",
"config",
"_isFlashUnusable",
"_on",
"eventType",
"listener",
"events",
"added",
"toLowerCase",
"on",
"push",
"emit",
"type",
"name",
"jsVersion",
"swfVersion",
"_off",
"foundIndex",
"perEventHandlers",
"off",
"splice",
"_listeners",
"_emit",
"event",
"eventCopy",
"returnVal",
"tmp",
"_createEvent",
"_preprocessEvent",
"_dispatchCallbacks",
"this",
"_mapClipDataToFlash",
"data",
"formatMap",
"_create",
"previousState",
"isFlashUnusable",
"maxWait",
"_embedSwf",
"_destroy",
"clearData",
"blur",
"_unembedSwf",
"_setData",
"format",
"dataObj",
"dataFormat",
"_fixLineEndings",
"_clearData",
"_getData",
"_focus",
"element",
"_removeClass",
"_addClass",
"newTitle",
"getAttribute",
"htmlBridge",
"_getHtmlBridge",
"setAttribute",
"useHandCursor",
"_getStyle",
"_setHandCursor",
"_reposition",
"_blur",
"removeAttribute",
"style",
"left",
"width",
"height",
"_activeElement",
"id",
"relatedTarget",
"currentTarget",
"timeStamp",
"msg",
"message",
"minimumVersion",
"clipboardData",
"setData",
"_mapClipResultsFromFlash",
"_getRelatedTarget",
"_addMouseData",
"targetEl",
"relatedTargetId",
"getElementById",
"srcElement",
"fromElement",
"toElement",
"pos",
"_getElementPosition",
"screenLeft",
"screenX",
"screenTop",
"screenY",
"scrollLeft",
"body",
"documentElement",
"scrollTop",
"pageX",
"_stageX",
"pageY",
"_stageY",
"clientX",
"clientY",
"moveX",
"movementX",
"moveY",
"movementY",
"x",
"y",
"offsetX",
"offsetY",
"layerX",
"layerY",
"_shouldPerformAsync",
"_dispatchCallback",
"func",
"context",
"async",
"apply",
"wildcardTypeHandlers",
"specificTypeHandlers",
"handlers",
"concat",
"originalContext",
"handleEvent",
"_getSandboxStatusFromErrorEvent",
"isSandboxed",
"sourceIsSwf",
"_source",
"_clearTimeoutsAndPolling",
"wasDeactivated",
"textContent",
"htmlContent",
"value",
"outerHTML",
"innerHTML",
"innerText",
"_queueEmitClipboardErrors",
"_safeActiveElement",
"focus",
"_fireMouseEvent",
"bubbles",
"cancelable",
"aftercopyEvent",
"errors",
"errorEvent",
"success",
"doc",
"defaults",
"view",
"defaultView",
"canBubble",
"detail",
"button",
"which",
"createEvent",
"dispatchEvent",
"ctrlKey",
"altKey",
"shiftKey",
"metaKey",
"initMouseEvent",
"_watchForSwfFallbackContent",
"pollWait",
"Math",
"min",
"fallbackContentId",
"_isElementVisible",
"_createHtmlBridge",
"container",
"className",
"position",
"_getSafeZIndex",
"flashBridge",
"nodeName",
"allowScriptAccess",
"_determineScriptAccess",
"allowNetworking",
"flashvars",
"_vars",
"swfUrl",
"_cacheBust",
"divToBeReplaced",
"appendChild",
"tmpDiv",
"usingActiveX",
"firstChild",
"replaceChild",
"display",
"removeSwfFromIE",
"removeChild",
"clipData",
"newClipData",
"text",
"html",
"rtf",
"clipResults",
"newResults",
"tmpHash",
"path",
"domain",
"domains",
"str",
"trustedOriginsExpanded",
"_extractDomain",
"protocol",
"originOrUrl",
"protocolIndex",
"pathIndex",
"_extractAllDomains",
"origins",
"resultsArray",
"currentDomain",
"configOptions",
"swfDomain",
"activeElement",
"c",
"cl",
"classNames",
"getPropertyValue",
"getBoundingClientRect",
"elRect",
"pageXOffset",
"pageYOffset",
"leftBorderWidth",
"clientLeft",
"topBorderWidth",
"clientTop",
"leftBodyOffset",
"topBodyOffset",
"bodyRect",
"htmlRect",
"right",
"bottom",
"styles",
"hasCssHeight",
"hasCssWidth",
"hasCssTop",
"hasCssLeft",
"cssKnows",
"rect",
"isVisible",
"visibility",
"enabled",
"setHandCursor",
"val",
"content",
"replaceRegex",
"doNotReassessFlashSupport",
"effectiveScriptOrigin",
"frame",
"frameError",
"frameElement",
"hasAttribute",
"_detectFlashSupport",
"parseFlashVersion",
"desc",
"isPepperFlash",
"flashPlayerFileName",
"inspectPlugin",
"plugin",
"hasFlash",
"flashVersion",
"description",
"filename",
"isPPAPI",
"ax",
"mimeType",
"isActiveX",
"plugins",
"mimeTypes",
"enabledPlugin",
"GetVariable",
"e1",
"e2",
"e3",
"_createClient",
"writable",
"configurable",
"enumerable",
"state",
"create",
"destroy",
"getData",
"activate",
"deactivate",
"_clientIdCounter",
"_clientMeta",
"_elementIdCounter",
"_elementMeta",
"_mouseHandlers",
"_clientConstructor",
"elements",
"client",
"instance",
"clip",
"_clientOn",
"meta",
"_clientOff",
"_clientListeners",
"_clientEmit",
"_clientShouldEmit",
"_clientDispatchCallbacks",
"_clientClip",
"_prepClip",
"zcClippingId",
"_addMouseHandlers",
"clippedElements",
"_clientUnclip",
"arrayIndex",
"clientIds",
"_removeMouseHandlers",
"_clientElements",
"_clientDestroy",
"unclip",
"clippedEls",
"hasClippedEls",
"goodTarget",
"goodRelTarget",
"goodClient",
"_suppressMouseEvents",
"stopImmediatePropagation",
"preventDefault",
"_elementMouseOver",
"addEventListener",
"mouseover",
"mouseout",
"mouseenter",
"mouseleave",
"mousemove",
"mouseHandlers",
"key",
"mouseEvents",
"removeEventListener",
"setText",
"setHtml",
"setRichText",
"richText",
"define",
"amd",
"module",
"exports"
],
mappings: "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",
sourcesContent: [
"/*! * ZeroClipboard * The ZeroClipboard library provides an easy way to copy text to the clipboard using an invisible Adobe Flash movie and a JavaScript interface. * Copyright (c) 2009-2015 Jon Rohan, James M. Greene * Licensed MIT * http://zeroclipboard.org/ * v2.3.0-beta.1 */ (function(window, undefined) { "use strict"; /** * Store references to critically important global functions that may be * overridden on certain web pages. */ var _window = window, _document = _window.document, _navigator = _window.navigator, _setTimeout = _window.setTimeout, _clearTimeout = _window.clearTimeout, _setInterval = _window.setInterval, _clearInterval = _window.clearInterval, _getComputedStyle = _window.getComputedStyle, _encodeURIComponent = _window.encodeURIComponent, _ActiveXObject = _window.ActiveXObject, _Error = _window.Error, _parseInt = _window.Number.parseInt || _window.parseInt, _parseFloat = _window.Number.parseFloat || _window.parseFloat, _isNaN = _window.Number.isNaN || _window.isNaN, _now = _window.Date.now, _keys = _window.Object.keys, _defineProperty = _window.Object.defineProperty, _hasOwn = _window.Object.prototype.hasOwnProperty, _slice = _window.Array.prototype.slice, _unwrap = function() { var unwrapper = function(el) { return el; }; if (typeof _window.wrap === "function" && typeof _window.unwrap === "function") { try { var div = _document.createElement("div"); var unwrappedDiv = _window.unwrap(div); if (div.nodeType === 1 && unwrappedDiv && unwrappedDiv.nodeType === 1) { unwrapper = _window.unwrap; } } catch (e) {} } return unwrapper; }(); /** * Convert an `arguments` object into an Array. * * @returns The arguments as an Array * @private */ var _args = function(argumentsObj) { return _slice.call(argumentsObj, 0); }; /** * Shallow-copy the owned, enumerable properties of one object over to another, similar to jQuery's `$.extend`. * * @returns The target object, augmented * @private */ var _extend = function() { var i, len, arg, prop, src, copy, args = _args(arguments), target = args[0] || {}; for (i = 1, len = args.length; i < len; i++) { if ((arg = args[i]) != null) { for (prop in arg) { if (_hasOwn.call(arg, prop)) { src = target[prop]; copy = arg[prop]; if (target !== copy && copy !== undefined) { target[prop] = copy; } } } } } return target; }; /** * Return a deep copy of the source object or array. * * @returns Object or Array * @private */ var _deepCopy = function(source) { var copy, i, len, prop; if (typeof source !== "object" || source == null || typeof source.nodeType === "number") { copy = source; } else if (typeof source.length === "number") { copy = []; for (i = 0, len = source.length; i < len; i++) { if (_hasOwn.call(source, i)) { copy[i] = _deepCopy(source[i]); } } } else { copy = {}; for (prop in source) { if (_hasOwn.call(source, prop)) { copy[prop] = _deepCopy(source[prop]); } } } return copy; }; /** * Makes a shallow copy of `obj` (like `_extend`) but filters its properties based on a list of `keys` to keep. * The inverse of `_omit`, mostly. The big difference is that these properties do NOT need to be enumerable to * be kept. * * @returns A new filtered object. * @private */ var _pick = function(obj, keys) { var newObj = {}; for (var i = 0, len = keys.length; i < len; i++) { if (keys[i] in obj) { newObj[keys[i]] = obj[keys[i]]; } } return newObj; }; /** * Makes a shallow copy of `obj` (like `_extend`) but filters its properties based on a list of `keys` to omit. * The inverse of `_pick`. * * @returns A new filtered object. * @private */ var _omit = function(obj, keys) { var newObj = {}; for (var prop in obj) { if (keys.indexOf(prop) === -1) { newObj[prop] = obj[prop]; } } return newObj; }; /** * Remove all owned, enumerable properties from an object. * * @returns The original object without its owned, enumerable properties. * @private */ var _deleteOwnProperties = function(obj) { if (obj) { for (var prop in obj) { if (_hasOwn.call(obj, prop)) { delete obj[prop]; } } } return obj; }; /** * Determine if an element is contained within another element. * * @returns Boolean * @private */ var _containedBy = function(el, ancestorEl) { if (el && el.nodeType === 1 && el.ownerDocument && ancestorEl && (ancestorEl.nodeType === 1 && ancestorEl.ownerDocument && ancestorEl.ownerDocument === el.ownerDocument || ancestorEl.nodeType === 9 && !ancestorEl.ownerDocument && ancestorEl === el.ownerDocument)) { do { if (el === ancestorEl) { return true; } el = el.parentNode; } while (el); } return false; }; /** * Get the URL path's parent directory. * * @returns String or `undefined` * @private */ var _getDirPathOfUrl = function(url) { var dir; if (typeof url === "string" && url) { dir = url.split("#")[0].split("?")[0]; dir = url.slice(0, url.lastIndexOf("/") + 1); } return dir; }; /** * Get the current script's URL by throwing an `Error` and analyzing it. * * @returns String or `undefined` * @private */ var _getCurrentScriptUrlFromErrorStack = function(stack) { var url, matches; if (typeof stack === "string" && stack) { matches = stack.match(/^(?:|[^:@]*@|.+\)@(?=http[s]?|file)|.+?\s+(?: at |@)(?:[^:\(]+ )*[\(]?)((?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/); if (matches && matches[1]) { url = matches[1]; } else { matches = stack.match(/\)@((?:http[s]?|file):\/\/[\/]?.+?\/[^:\)]*?)(?::\d+)(?::\d+)?/); if (matches && matches[1]) { url = matches[1]; } } } return url; }; /** * Get the current script's URL by throwing an `Error` and analyzing it. * * @returns String or `undefined` * @private */ var _getCurrentScriptUrlFromError = function() { var url, err; try { throw new _Error(); } catch (e) { err = e; } if (err) { url = err.sourceURL || err.fileName || _getCurrentScriptUrlFromErrorStack(err.stack); } return url; }; /** * Get the current script's URL. * * @returns String or `undefined` * @private */ var _getCurrentScriptUrl = function() { var jsPath, scripts, i; if (_document.currentScript && (jsPath = _document.currentScript.src)) { return jsPath; } scripts = _document.getElementsByTagName("script"); if (scripts.length === 1) { return scripts[0].src || undefined; } if ("readyState" in scripts[0]) { for (i = scripts.length; i--; ) { if (scripts[i].readyState === "interactive" && (jsPath = scripts[i].src)) { return jsPath; } } } if (_document.readyState === "loading" && (jsPath = scripts[scripts.length - 1].src)) { return jsPath; } if (jsPath = _getCurrentScriptUrlFromError()) { return jsPath; } return undefined; }; /** * Get the unanimous parent directory of ALL script tags. * If any script tags are either (a) inline or (b) from differing parent * directories, this method must return `undefined`. * * @returns String or `undefined` * @private */ var _getUnanimousScriptParentDir = function() { var i, jsDir, jsPath, scripts = _document.getElementsByTagName("script"); for (i = scripts.length; i--; ) { if (!(jsPath = scripts[i].src)) { jsDir = null; break; } jsPath = _getDirPathOfUrl(jsPath); if (jsDir == null) { jsDir = jsPath; } else if (jsDir !== jsPath) { jsDir = null; break; } } return jsDir || undefined; }; /** * Get the presumed location of the "ZeroClipboard.swf" file, based on the location * of the executing JavaScript file (e.g. "ZeroClipboard.js", etc.). * * @returns String * @private */ var _getDefaultSwfPath = function() { var jsDir = _getDirPathOfUrl(_getCurrentScriptUrl()) || _getUnanimousScriptParentDir() || ""; return jsDir + "ZeroClipboard.swf"; }; /** * Is the client's operating system some version of Windows? * * @returns Boolean * @private */ var _isWindows = function() { var isWindowsRegex = /win(dows|[\s]?(nt|me|ce|xp|vista|[\d]+))/i; return !!_navigator && (isWindowsRegex.test(_navigator.appVersion || "") || isWindowsRegex.test(_navigator.platform || "") || (_navigator.userAgent || "").indexOf("Windows") !== -1); }; /** * Keep track of if the page is framed (in an `iframe`). This can never change. * @private */ var _pageIsFramed = function() { return window.opener == null && (!!window.top && window != window.top || !!window.parent && window != window.parent); }(); /** * Keep track of the state of the Flash object. * @private */ var _flashState = { bridge: null, version: "0.0.0", pluginType: "unknown", disabled: null, outdated: null, sandboxed: null, unavailable: null, degraded: null, deactivated: null, overdue: null, ready: null }; /** * The minimum Flash Player version required to use ZeroClipboard completely. * @readonly * @private */ var _minimumFlashVersion = "11.0.0"; /** * The ZeroClipboard library version number, as reported by Flash, at the time the SWF was compiled. */ var _zcSwfVersion; /** * Keep track of all event listener registrations. * @private */ var _handlers = {}; /** * Keep track of the currently activated element. * @private */ var _currentElement; /** * Keep track of the element that was activated when a `copy` process started. * @private */ var _copyTarget; /** * Keep track of data for the pending clipboard transaction. * @private */ var _clipData = {}; /** * Keep track of data formats for the pending clipboard transaction. * @private */ var _clipDataFormatMap = null; /** * Keep track of the Flash availability check timeout. * @private */ var _flashCheckTimeout = 0; /** * Keep track of SWF network errors interval polling. * @private */ var _swfFallbackCheckInterval = 0; /** * The `message` store for events * @private */ var _eventMessages = { ready: "Flash communication is established", error: { "flash-disabled": "Flash is disabled or not installed. May also be attempting to run Flash in a sandboxed iframe, which is impossible.", "flash-outdated": "Flash is too outdated to support ZeroClipboard", "flash-sandboxed": "Attempting to run Flash in a sandboxed iframe, which is impossible", "flash-unavailable": "Flash is unable to communicate bidirectionally with JavaScript", "flash-degraded": "Flash is unable to preserve data fidelity when communicating with JavaScript", "flash-deactivated": "Flash is too outdated for your browser and/or is configured as click-to-activate.\nThis may also mean that the ZeroClipboard SWF object could not be loaded, so please check your `swfPath` configuration and/or network connectivity.\nMay also be attempting to run Flash in a sandboxed iframe, which is impossible.", "flash-overdue": "Flash communication was established but NOT within the acceptable time limit", "version-mismatch": "ZeroClipboard JS version number does not match ZeroClipboard SWF version number", "clipboard-error": "At least one error was thrown while ZeroClipboard was attempting to inject your data into the clipboard", "config-mismatch": "ZeroClipboard configuration does not match Flash's reality", "swf-not-found": "The ZeroClipboard SWF object could not be loaded, so please check your `swfPath` configuration and/or network connectivity" } }; /** * The `name`s of `error` events that can only occur is Flash has at least * been able to load the SWF successfully. * @private */ var _errorsThatOnlyOccurAfterFlashLoads = [ "flash-unavailable", "flash-degraded", "flash-overdue", "version-mismatch", "config-mismatch", "clipboard-error" ]; /** * The `name`s of `error` events that should likely result in the `_flashState` * variable's property values being updated. * @private */ var _flashStateErrorNames = [ "flash-disabled", "flash-outdated", "flash-sandboxed", "flash-unavailable", "flash-degraded", "flash-deactivated", "flash-overdue" ]; /** * A RegExp to match the `name` property of `error` events related to Flash. * @private */ var _flashStateErrorNameMatchingRegex = new RegExp("^flash-(" + _flashStateErrorNames.map(function(errorName) { return errorName.replace(/^flash-/, ""); }).join("|") + ")$"); /** * A RegExp to match the `name` property of `error` events related to Flash, * which is enabled. * @private */ var _flashStateEnabledErrorNameMatchingRegex = new RegExp("^flash-(" + _flashStateErrorNames.slice(1).map(function(errorName) { return errorName.replace(/^flash-/, ""); }).join("|") + ")$"); /** * ZeroClipboard configuration defaults for the Core module. * @private */ var _globalConfig = { swfPath: _getDefaultSwfPath(), trustedDomains: window.location.host ? [ window.location.host ] : [], cacheBust: true, forceEnhancedClipboard: false, flashLoadTimeout: 3e4, autoActivate: true, bubbleEvents: true, fixLineEndings: true, containerId: "global-zeroclipboard-html-bridge", containerClass: "global-zeroclipboard-container", swfObjectId: "global-zeroclipboard-flash-bridge", hoverClass: "zeroclipboard-is-hover", activeClass: "zeroclipboard-is-active", forceHandCursor: false, title: null, zIndex: 999999999 }; /** * The underlying implementation of `ZeroClipboard.config`. * @private */ var _config = function(options) { if (typeof options === "object" && options !== null) { for (var prop in options) { if (_hasOwn.call(options, prop)) { if (/^(?:forceHandCursor|title|zIndex|bubbleEvents|fixLineEndings)$/.test(prop)) { _globalConfig[prop] = options[prop]; } else if (_flashState.bridge == null) { if (prop === "containerId" || prop === "swfObjectId") { if (_isValidHtml4Id(options[prop])) { _globalConfig[prop] = options[prop]; } else { throw new Error("The specified `" + prop + "` value is not valid as an HTML4 Element ID"); } } else { _globalConfig[prop] = options[prop]; } } } } } if (typeof options === "string" && options) { if (_hasOwn.call(_globalConfig, options)) { return _globalConfig[options]; } return; } return _deepCopy(_globalConfig); }; /** * The underlying implementation of `ZeroClipboard.state`. * @private */ var _state = function() { _detectSandbox(); return { browser: _pick(_navigator, [ "userAgent", "platform", "appName", "appVersion" ]), flash: _omit(_flashState, [ "bridge" ]), zeroclipboard: { version: ZeroClipboard.version, config: ZeroClipboard.config() } }; }; /** * The underlying implementation of `ZeroClipboard.isFlashUnusable`. * @private */ var _isFlashUnusable = function() { return !!(_flashState.disabled || _flashState.outdated || _flashState.sandboxed || _flashState.unavailable || _flashState.degraded || _flashState.deactivated); }; /** * The underlying implementation of `ZeroClipboard.on`. * @private */ var _on = function(eventType, listener) { var i, len, events, added = {}; if (typeof eventType === "string" && eventType) { events = eventType.toLowerCase().split(/\s+/); } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") { for (i in eventType) { if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") { ZeroClipboard.on(i, eventType[i]); } } } if (events && events.length) { for (i = 0, len = events.length; i < len; i++) { eventType = events[i].replace(/^on/, ""); added[eventType] = true; if (!_handlers[eventType]) { _handlers[eventType] = []; } _handlers[eventType].push(listener); } if (added.ready && _flashState.ready) { ZeroClipboard.emit({ type: "ready" }); } if (added.error) { for (i = 0, len = _flashStateErrorNames.length; i < len; i++) { if (_flashState[_flashStateErrorNames[i].replace(/^flash-/, "")] === true) { ZeroClipboard.emit({ type: "error", name: _flashStateErrorNames[i] }); break; } } if (_zcSwfVersion !== undefined && ZeroClipboard.version !== _zcSwfVersion) { ZeroClipboard.emit({ type: "error", name: "version-mismatch", jsVersion: ZeroClipboard.version, swfVersion: _zcSwfVersion }); } } } return ZeroClipboard; }; /** * The underlying implementation of `ZeroClipboard.off`. * @private */ var _off = function(eventType, listener) { var i, len, foundIndex, events, perEventHandlers; if (arguments.length === 0) { events = _keys(_handlers); } else if (typeof eventType === "string" && eventType) { events = eventType.split(/\s+/); } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") { for (i in eventType) { if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") { ZeroClipboard.off(i, eventType[i]); } } } if (events && events.length) { for (i = 0, len = events.length; i < len; i++) { eventType = events[i].toLowerCase().replace(/^on/, ""); perEventHandlers = _handlers[eventType]; if (perEventHandlers && perEventHandlers.length) { if (listener) { foundIndex = perEventHandlers.indexOf(listener); while (foundIndex !== -1) { perEventHandlers.splice(foundIndex, 1); foundIndex = perEventHandlers.indexOf(listener, foundIndex); } } else { perEventHandlers.length = 0; } } } } return ZeroClipboard; }; /** * The underlying implementation of `ZeroClipboard.handlers`. * @private */ var _listeners = function(eventType) { var copy; if (typeof eventType === "string" && eventType) { copy = _deepCopy(_handlers[eventType]) || null; } else { copy = _deepCopy(_handlers); } return copy; }; /** * The underlying implementation of `ZeroClipboard.emit`. * @private */ var _emit = function(event) { var eventCopy, returnVal, tmp; event = _createEvent(event); if (!event) { return; } if (_preprocessEvent(event)) { return; } if (event.type === "ready" && _flashState.overdue === true) { return ZeroClipboard.emit({ type: "error", name: "flash-overdue" }); } eventCopy = _extend({}, event); _dispatchCallbacks.call(this, eventCopy); if (event.type === "copy") { tmp = _mapClipDataToFlash(_clipData); returnVal = tmp.data; _clipDataFormatMap = tmp.formatMap; } return returnVal; }; /** * The underlying implementation of `ZeroClipboard.create`. * @private */ var _create = function() { var previousState = _flashState.sandboxed; _detectSandbox(); if (typeof _flashState.ready !== "boolean") { _flashState.ready = false; } if (_flashState.sandboxed !== previousState && _flashState.sandboxed === true) { _flashState.ready = false; ZeroClipboard.emit({ type: "error", name: "flash-sandboxed" }); } else if (!ZeroClipboard.isFlashUnusable() && _flashState.bridge === null) { var maxWait = _globalConfig.flashLoadTimeout; if (typeof maxWait === "number" && maxWait >= 0) { _flashCheckTimeout = _setTimeout(function() { if (typeof _flashState.deactivated !== "boolean") { _flashState.deactivated = true; } if (_flashState.deactivated === true) { ZeroClipboard.emit({ type: "error", name: "flash-deactivated" }); } }, maxWait); } _flashState.overdue = false; _embedSwf(); } }; /** * The underlying implementation of `ZeroClipboard.destroy`. * @private */ var _destroy = function() { ZeroClipboard.clearData(); ZeroClipboard.blur(); ZeroClipboard.emit("destroy"); _unembedSwf(); ZeroClipboard.off(); }; /** * The underlying implementation of `ZeroClipboard.setData`. * @private */ var _setData = function(format, data) { var dataObj; if (typeof format === "object" && format && typeof data === "undefined") { dataObj = format; ZeroClipboard.clearData(); } else if (typeof format === "string" && format) { dataObj = {}; dataObj[format] = data; } else { return; } for (var dataFormat in dataObj) { if (typeof dataFormat === "string" && dataFormat && _hasOwn.call(dataObj, dataFormat) && typeof dataObj[dataFormat] === "string" && dataObj[dataFormat]) { _clipData[dataFormat] = _fixLineEndings(dataObj[dataFormat]); } } }; /** * The underlying implementation of `ZeroClipboard.clearData`. * @private */ var _clearData = function(format) { if (typeof format === "undefined") { _deleteOwnProperties(_clipData); _clipDataFormatMap = null; } else if (typeof format === "string" && _hasOwn.call(_clipData, format)) { delete _clipData[format]; } }; /** * The underlying implementation of `ZeroClipboard.getData`. * @private */ var _getData = function(format) { if (typeof format === "undefined") { return _deepCopy(_clipData); } else if (typeof format === "string" && _hasOwn.call(_clipData, format)) { return _clipData[format]; } }; /** * The underlying implementation of `ZeroClipboard.focus`/`ZeroClipboard.activate`. * @private */ var _focus = function(element) { if (!(element && element.nodeType === 1)) { return; } if (_currentElement) { _removeClass(_currentElement, _globalConfig.activeClass); if (_currentElement !== element) { _removeClass(_currentElement, _globalConfig.hoverClass); } } _currentElement = element; _addClass(element, _globalConfig.hoverClass); var newTitle = element.getAttribute("title") || _globalConfig.title; if (typeof newTitle === "string" && newTitle) { var htmlBridge = _getHtmlBridge(_flashState.bridge); if (htmlBridge) { htmlBridge.setAttribute("title", newTitle); } } var useHandCursor = _globalConfig.forceHandCursor === true || _getStyle(element, "cursor") === "pointer"; _setHandCursor(useHandCursor); _reposition(); }; /** * The underlying implementation of `ZeroClipboard.blur`/`ZeroClipboard.deactivate`. * @private */ var _blur = function() { var htmlBridge = _getHtmlBridge(_flashState.bridge); if (htmlBridge) { htmlBridge.removeAttribute("title"); htmlBridge.style.left = "0px"; htmlBridge.style.top = "-9999px"; htmlBridge.style.width = "1px"; htmlBridge.style.height = "1px"; } if (_currentElement) { _removeClass(_currentElement, _globalConfig.hoverClass); _removeClass(_currentElement, _globalConfig.activeClass); _currentElement = null; } }; /** * The underlying implementation of `ZeroClipboard.activeElement`. * @private */ var _activeElement = function() { return _currentElement || null; }; /** * Check if a value is a valid HTML4 `ID` or `Name` token. * @private */ var _isValidHtml4Id = function(id) { return typeof id === "string" && id && /^[A-Za-z][A-Za-z0-9_:\-\.]*$/.test(id); }; /** * Create or update an `event` object, based on the `eventType`. * @private */ var _createEvent = function(event) { var eventType; if (typeof event === "string" && event) { eventType = event; event = {}; } else if (typeof event === "object" && event && typeof event.type === "string" && event.type) { eventType = event.type; } if (!eventType) { return; } eventType = eventType.toLowerCase(); if (!event.target && (/^(copy|aftercopy|_click)$/.test(eventType) || eventType === "error" && event.name === "clipboard-error")) { event.target = _copyTarget; } _extend(event, { type: eventType, target: event.target || _currentElement || null, relatedTarget: event.relatedTarget || null, currentTarget: _flashState && _flashState.bridge || null, timeStamp: event.timeStamp || _now() || null }); var msg = _eventMessages[event.type]; if (event.type === "error" && event.name && msg) { msg = msg[event.name]; } if (msg) { event.message = msg; } if (event.type === "ready") { _extend(event, { target: null, version: _flashState.version }); } if (event.type === "error") { if (_flashStateErrorNameMatchingRegex.test(event.name)) { _extend(event, { target: null, minimumVersion: _minimumFlashVersion }); } if (_flashStateEnabledErrorNameMatchingRegex.test(event.name)) { _extend(event, { version: _flashState.version }); } } if (event.type === "copy") { event.clipboardData = { setData: ZeroClipboard.setData, clearData: ZeroClipboard.clearData }; } if (event.type === "aftercopy") { event = _mapClipResultsFromFlash(event, _clipDataFormatMap); } if (event.target && !event.relatedTarget) { event.relatedTarget = _getRelatedTarget(event.target); } return _addMouseData(event); }; /** * Get a relatedTarget from the target's `data-clipboard-target` attribute * @private */ var _getRelatedTarget = function(targetEl) { var relatedTargetId = targetEl && targetEl.getAttribute && targetEl.getAttribute("data-clipboard-target"); return relatedTargetId ? _document.getElementById(relatedTargetId) : null; }; /** * Add element and position data to `MouseEvent` instances * @private */ var _addMouseData = function(event) { if (event && /^_(?:click|mouse(?:over|out|down|up|move))$/.test(event.type)) { var srcElement = event.target; var fromElement = event.type === "_mouseover" && event.relatedTarget ? event.relatedTarget : undefined; var toElement = event.type === "_mouseout" && event.relatedTarget ? event.relatedTarget : undefined; var pos = _getElementPosition(srcElement); var screenLeft = _window.screenLeft || _window.screenX || 0; var screenTop = _window.screenTop || _window.screenY || 0; var scrollLeft = _document.body.scrollLeft + _document.documentElement.scrollLeft; var scrollTop = _document.body.scrollTop + _document.documentElement.scrollTop; var pageX = pos.left + (typeof event._stageX === "number" ? event._stageX : 0); var pageY = pos.top + (typeof event._stageY === "number" ? event._stageY : 0); var clientX = pageX - scrollLeft; var clientY = pageY - scrollTop; var screenX = screenLeft + clientX; var screenY = screenTop + clientY; var moveX = typeof event.movementX === "number" ? event.movementX : 0; var moveY = typeof event.movementY === "number" ? event.movementY : 0; delete event._stageX; delete event._stageY; _extend(event, { srcElement: srcElement, fromElement: fromElement, toElement: toElement, screenX: screenX, screenY: screenY, pageX: pageX, pageY: pageY, clientX: clientX, clientY: clientY, x: clientX, y: clientY, movementX: moveX, movementY: moveY, offsetX: 0, offsetY: 0, layerX: 0, layerY: 0 }); } return event; }; /** * Determine if an event's registered handlers should be execute synchronously or asynchronously. * * @returns {boolean} * @private */ var _shouldPerformAsync = function(event) { var eventType = event && typeof event.type === "string" && event.type || ""; return !/^(?:(?:before)?copy|destroy)$/.test(eventType); }; /** * Control if a callback should be executed asynchronously or not. * * @returns `undefined` * @private */ var _dispatchCallback = function(func, context, args, async) { if (async) { _setTimeout(function() { func.apply(context, args); }, 0); } else { func.apply(context, args); } }; /** * Handle the actual dispatching of events to client instances. * * @returns `undefined` * @private */ var _dispatchCallbacks = function(event) { if (!(typeof event === "object" && event && event.type)) { return; } var async = _shouldPerformAsync(event); var wildcardTypeHandlers = _handlers["*"] || []; var specificTypeHandlers = _handlers[event.type] || []; var handlers = wildcardTypeHandlers.concat(specificTypeHandlers); if (handlers && handlers.length) { var i, len, func, context, eventCopy, originalContext = this; for (i = 0, len = handlers.length; i < len; i++) { func = handlers[i]; context = originalContext; if (typeof func === "string" && typeof _window[func] === "function") { func = _window[func]; } if (typeof func === "object" && func && typeof func.handleEvent === "function") { context = func; func = func.handleEvent; } if (typeof func === "function") { eventCopy = _extend({}, event); _dispatchCallback(func, context, [ eventCopy ], async); } } } return this; }; /** * Check an `error` event's `name` property to see if Flash has * already loaded, which rules out possible `iframe` sandboxing. * @private */ var _getSandboxStatusFromErrorEvent = function(event) { var isSandboxed = null; if (_pageIsFramed === false || event && event.type === "error" && event.name && _errorsThatOnlyOccurAfterFlashLoads.indexOf(event.name) !== -1) { isSandboxed = false; } return isSandboxed; }; /** * Preprocess any special behaviors, reactions, or state changes after receiving this event. * Executes only once per event emitted, NOT once per client. * @private */ var _preprocessEvent = function(event) { var element = event.target || _currentElement || null; var sourceIsSwf = event._source === "swf"; delete event._source; switch (event.type) { case "error": var isSandboxed = event.name === "flash-sandboxed" || _getSandboxStatusFromErrorEvent(event); if (typeof isSandboxed === "boolean") { _flashState.sandboxed = isSandboxed; } if (_flashStateErrorNames.indexOf(event.name) !== -1) { _extend(_flashState, { disabled: event.name === "flash-disabled", outdated: event.name === "flash-outdated", unavailable: event.name === "flash-unavailable", degraded: event.name === "flash-degraded", deactivated: event.name === "flash-deactivated", overdue: event.name === "flash-overdue", ready: false }); } else if (event.name === "version-mismatch") { _zcSwfVersion = event.swfVersion; _extend(_flashState, { disabled: false, outdated: false, unavailable: false, degraded: false, deactivated: false, overdue: false, ready: false }); } _clearTimeoutsAndPolling(); break; case "ready": _zcSwfVersion = event.swfVersion; var wasDeactivated = _flashState.deactivated === true; _extend(_flashState, { disabled: false, outdated: false, sandboxed: false, unavailable: false, degraded: false, deactivated: false, overdue: wasDeactivated, ready: !wasDeactivated }); _clearTimeoutsAndPolling(); break; case "beforecopy": _copyTarget = element; break; case "copy": var textContent, htmlContent, targetEl = event.relatedTarget; if (!(_clipData["text/html"] || _clipData["text/plain"]) && targetEl && (htmlContent = targetEl.value || targetEl.outerHTML || targetEl.innerHTML) && (textContent = targetEl.value || targetEl.textContent || targetEl.innerText)) { event.clipboardData.clearData(); event.clipboardData.setData("text/plain", textContent); if (htmlContent !== textContent) { event.clipboardData.setData("text/html", htmlContent); } } else if (!_clipData["text/plain"] && event.target && (textContent = event.target.getAttribute("data-clipboard-text"))) { event.clipboardData.clearData(); event.clipboardData.setData("text/plain", textContent); } break; case "aftercopy": _queueEmitClipboardErrors(event); ZeroClipboard.clearData(); if (element && element !== _safeActiveElement() && element.focus) { element.focus(); } break; case "_mouseover": ZeroClipboard.focus(element); if (_globalConfig.bubbleEvents === true && sourceIsSwf) { if (element && element !== event.relatedTarget && !_containedBy(event.relatedTarget, element)) { _fireMouseEvent(_extend({}, event, { type: "mouseenter", bubbles: false, cancelable: false })); } _fireMouseEvent(_extend({}, event, { type: "mouseover" })); } break; case "_mouseout": ZeroClipboard.blur(); if (_globalConfig.bubbleEvents === true && sourceIsSwf) { if (element && element !== event.relatedTarget && !_containedBy(event.relatedTarget, element)) { _fireMouseEvent(_extend({}, event, { type: "mouseleave", bubbles: false, cancelable: false })); } _fireMouseEvent(_extend({}, event, { type: "mouseout" })); } break; case "_mousedown": _addClass(element, _globalConfig.activeClass); if (_globalConfig.bubbleEvents === true && sourceIsSwf) { _fireMouseEvent(_extend({}, event, { type: event.type.slice(1) })); } break; case "_mouseup": _removeClass(element, _globalConfig.activeClass); if (_globalConfig.bubbleEvents === true && sourceIsSwf) { _fireMouseEvent(_extend({}, event, { type: event.type.slice(1) })); } break; case "_click": _copyTarget = null; if (_globalConfig.bubbleEvents === true && sourceIsSwf) { _fireMouseEvent(_extend({}, event, { type: event.type.slice(1) })); } break; case "_mousemove": if (_globalConfig.bubbleEvents === true && sourceIsSwf) { _fireMouseEvent(_extend({}, event, { type: event.type.slice(1) })); } break; } if (/^_(?:click|mouse(?:over|out|down|up|move))$/.test(event.type)) { return true; } }; /** * Check an "aftercopy" event for clipboard errors and emit a corresponding "error" event. * @private */ var _queueEmitClipboardErrors = function(aftercopyEvent) { if (aftercopyEvent.errors && aftercopyEvent.errors.length > 0) { var errorEvent = _deepCopy(aftercopyEvent); _extend(errorEvent, { type: "error", name: "clipboard-error" }); delete errorEvent.success; _setTimeout(function() { ZeroClipboard.emit(errorEvent); }, 0); } }; /** * Dispatch a synthetic MouseEvent. * * @returns `undefined` * @private */ var _fireMouseEvent = function(event) { if (!(event && typeof event.type === "string" && event)) { return; } var e, target = event.target || null, doc = target && target.ownerDocument || _document, defaults = { view: doc.defaultView || _window, canBubble: true, cancelable: true, detail: event.type === "click" ? 1 : 0, button: typeof event.which === "number" ? event.which - 1 : typeof event.button === "number" ? event.button : doc.createEvent ? 0 : 1 }, args = _extend(defaults, event); if (!target) { return; } if (doc.createEvent && target.dispatchEvent) { args = [ args.type, args.canBubble, args.cancelable, args.view, args.detail, args.screenX, args.screenY, args.clientX, args.clientY, args.ctrlKey, args.altKey, args.shiftKey, args.metaKey, args.button, args.relatedTarget ]; e = doc.createEvent("MouseEvents"); if (e.initMouseEvent) { e.initMouseEvent.apply(e, args); e._source = "js"; target.dispatchEvent(e); } } }; /** * Continuously poll the DOM until either: * (a) the fallback content becomes visible, or * (b) we receive an event from SWF (handled elsewhere) * * IMPORTANT: * This is NOT a necessary check but it can result in significantly faster * detection of bad `swfPath` configuration and/or network/server issues [in * supported browsers] than waiting for the entire `flashLoadTimeout` duration * to elapse before detecting that the SWF cannot be loaded. The detection * duration can be anywhere from 10-30 times faster [in supported browsers] by * using this approach. * * @returns `undefined` * @private */ var _watchForSwfFallbackContent = function() { var maxWait = _globalConfig.flashLoadTimeout; if (typeof maxWait === "number" && maxWait >= 0) { var pollWait = Math.min(1e3, maxWait / 10); var fallbackContentId = _globalConfig.swfObjectId + "_fallbackContent"; _swfFallbackCheckInterval = _setInterval(function() { var el = _document.getElementById(fallbackContentId); if (_isElementVisible(el)) { _clearTimeoutsAndPolling(); _flashState.deactivated = null; ZeroClipboard.emit({ type: "error", name: "swf-not-found" }); } }, pollWait); } }; /** * Create the HTML bridge element to embed the Flash object into. * @private */ var _createHtmlBridge = function() { var container = _document.createElement("div"); container.id = _globalConfig.containerId; container.className = _globalConfig.containerClass; container.style.position = "absolute"; container.style.left = "0px"; container.style.top = "-9999px"; container.style.width = "1px"; container.style.height = "1px"; container.style.zIndex = "" + _getSafeZIndex(_globalConfig.zIndex); return container; }; /** * Get the HTML element container that wraps the Flash bridge object/element. * @private */ var _getHtmlBridge = function(flashBridge) { var htmlBridge = flashBridge && flashBridge.parentNode; while (htmlBridge && htmlBridge.nodeName === "OBJECT" && htmlBridge.parentNode) { htmlBridge = htmlBridge.parentNode; } return htmlBridge || null; }; /** * Create the SWF object. * * @returns The SWF object reference. * @private */ var _embedSwf = function() { var len, flashBridge = _flashState.bridge, container = _getHtmlBridge(flashBridge); if (!flashBridge) { var allowScriptAccess = _determineScriptAccess(_window.location.host, _globalConfig); var allowNetworking = allowScriptAccess === "never" ? "none" : "all"; var flashvars = _vars(_extend({ jsVersion: ZeroClipboard.version }, _globalConfig)); var swfUrl = _globalConfig.swfPath + _cacheBust(_globalConfig.swfPath, _globalConfig); container = _createHtmlBridge(); var divToBeReplaced = _document.createElement("div"); container.appendChild(divToBeReplaced); _document.body.appendChild(container); var tmpDiv = _document.createElement("div"); var usingActiveX = _flashState.pluginType === "activex"; tmpDiv.innerHTML = '<object id="' + _globalConfig.swfObjectId + '" name="' + _globalConfig.swfObjectId + '" ' + 'width="100%" height="100%" ' + (usingActiveX ? 'classid="clsid:d27cdb6e-ae6d-11cf-96b8-444553540000"' : 'type="application/x-shockwave-flash" data="' + swfUrl + '"') + ">" + (usingActiveX ? '<param name="movie" value="' + swfUrl + '"/>' : "") + '<param name="allowScriptAccess" value="' + allowScriptAccess + '"/>' + '<param name="allowNetworking" value="' + allowNetworking + '"/>' + '<param name="menu" value="false"/>' + '<param name="wmode" value="transparent"/>' + '<param name="flashvars" value="' + flashvars + '"/>' + '<div id="' + _globalConfig.swfObjectId + '_fallbackContent">&nbsp;</div>' + "</object>"; flashBridge = tmpDiv.firstChild; tmpDiv = null; _unwrap(flashBridge).ZeroClipboard = ZeroClipboard; container.replaceChild(flashBridge, divToBeReplaced); _watchForSwfFallbackContent(); } if (!flashBridge) { flashBridge = _document[_globalConfig.swfObjectId]; if (flashBridge && (len = flashBridge.length)) { flashBridge = flashBridge[len - 1]; } if (!flashBridge && container) { flashBridge = container.firstChild; } } _flashState.bridge = flashBridge || null; return flashBridge; }; /** * Destroy the SWF object. * @private */ var _unembedSwf = function() { var flashBridge = _flashState.bridge; if (flashBridge) { var htmlBridge = _getHtmlBridge(flashBridge); if (htmlBridge) { if (_flashState.pluginType === "activex" && "readyState" in flashBridge) { flashBridge.style.display = "none"; (function removeSwfFromIE() { if (flashBridge.readyState === 4) { for (var prop in flashBridge) { if (typeof flashBridge[prop] === "function") { flashBridge[prop] = null; } } if (flashBridge.parentNode) { flashBridge.parentNode.removeChild(flashBridge); } if (htmlBridge.parentNode) { htmlBridge.parentNode.removeChild(htmlBridge); } } else { _setTimeout(removeSwfFromIE, 10); } })(); } else { if (flashBridge.parentNode) { flashBridge.parentNode.removeChild(flashBridge); } if (htmlBridge.parentNode) { htmlBridge.parentNode.removeChild(htmlBridge); } } } _clearTimeoutsAndPolling(); _flashState.ready = null; _flashState.bridge = null; _flashState.deactivated = null; _zcSwfVersion = undefined; } }; /** * Map the data format names of the "clipData" to Flash-friendly names. * * @returns A new transformed object. * @private */ var _mapClipDataToFlash = function(clipData) { var newClipData = {}, formatMap = {}; if (!(typeof clipData === "object" && clipData)) { return; } for (var dataFormat in clipData) { if (dataFormat && _hasOwn.call(clipData, dataFormat) && typeof clipData[dataFormat] === "string" && clipData[dataFormat]) { switch (dataFormat.toLowerCase()) { case "text/plain": case "text": case "air:text": case "flash:text": newClipData.text = clipData[dataFormat]; formatMap.text = dataFormat; break; case "text/html": case "html": case "air:html": case "flash:html": newClipData.html = clipData[dataFormat]; formatMap.html = dataFormat; break; case "application/rtf": case "text/rtf": case "rtf": case "richtext": case "air:rtf": case "flash:rtf": newClipData.rtf = clipData[dataFormat]; formatMap.rtf = dataFormat; break; default: break; } } } return { data: newClipData, formatMap: formatMap }; }; /** * Map the data format names from Flash-friendly names back to their original "clipData" names (via a format mapping). * * @returns A new transformed object. * @private */ var _mapClipResultsFromFlash = function(clipResults, formatMap) { if (!(typeof clipResults === "object" && clipResults && typeof formatMap === "object" && formatMap)) { return clipResults; } var newResults = {}; for (var prop in clipResults) { if (_hasOwn.call(clipResults, prop)) { if (prop === "errors") { newResults[prop] = clipResults[prop] ? clipResults[prop].slice() : []; for (var i = 0, len = newResults[prop].length; i < len; i++) { newResults[prop][i].format = formatMap[newResults[prop][i].format]; } } else if (prop !== "success" && prop !== "data") { newResults[prop] = clipResults[prop]; } else { newResults[prop] = {}; var tmpHash = clipResults[prop]; for (var dataFormat in tmpHash) { if (dataFormat && _hasOwn.call(tmpHash, dataFormat) && _hasOwn.call(formatMap, dataFormat)) { newResults[prop][formatMap[dataFormat]] = tmpHash[dataFormat]; } } } } } return newResults; }; /** * Will look at a path, and will create a "?noCache={time}" or "&noCache={time}" * query param string to return. Does NOT append that string to the original path. * This is useful because ExternalInterface often breaks when a Flash SWF is cached. * * @returns The `noCache` query param with necessary "?"/"&" prefix. * @private */ var _cacheBust = function(path, options) { var cacheBust = options == null || options && options.cacheBust === true; if (cacheBust) { return (path.indexOf("?") === -1 ? "?" : "&") + "noCache=" + _now(); } else { return ""; } }; /** * Creates a query string for the FlashVars param. * Does NOT include the cache-busting query param. * * @returns FlashVars query string * @private */ var _vars = function(options) { var i, len, domain, domains, str = "", trustedOriginsExpanded = []; if (options.trustedDomains) { if (typeof options.trustedDomains === "string") { domains = [ options.trustedDomains ]; } else if (typeof options.trustedDomains === "object" && "length" in options.trustedDomains) { domains = options.trustedDomains; } } if (domains && domains.length) { for (i = 0, len = domains.length; i < len; i++) { if (_hasOwn.call(domains, i) && domains[i] && typeof domains[i] === "string") { domain = _extractDomain(domains[i]); if (!domain) { continue; } if (domain === "*") { trustedOriginsExpanded.length = 0; trustedOriginsExpanded.push(domain); break; } trustedOriginsExpanded.push.apply(trustedOriginsExpanded, [ domain, "//" + domain, _window.location.protocol + "//" + domain ]); } } } if (trustedOriginsExpanded.length) { str += "trustedOrigins=" + _encodeURIComponent(trustedOriginsExpanded.join(",")); } if (options.forceEnhancedClipboard === true) { str += (str ? "&" : "") + "forceEnhancedClipboard=true"; } if (typeof options.swfObjectId === "string" && options.swfObjectId) { str += (str ? "&" : "") + "swfObjectId=" + _encodeURIComponent(options.swfObjectId); } if (typeof options.jsVersion === "string" && options.jsVersion) { str += (str ? "&" : "") + "jsVersion=" + _encodeURIComponent(options.jsVersion); } return str; }; /** * Extract the domain (e.g. "github.com") from an origin (e.g. "https://github.com") or * URL (e.g. "https://github.com/zeroclipboard/zeroclipboard/"). * * @returns the domain * @private */ var _extractDomain = function(originOrUrl) { if (originOrUrl == null || originOrUrl === "") { return null; } originOrUrl = originOrUrl.replace(/^\s+|\s+$/g, ""); if (originOrUrl === "") { return null; } var protocolIndex = originOrUrl.indexOf("//"); originOrUrl = protocolIndex === -1 ? originOrUrl : originOrUrl.slice(protocolIndex + 2); var pathIndex = originOrUrl.indexOf("/"); originOrUrl = pathIndex === -1 ? originOrUrl : protocolIndex === -1 || pathIndex === 0 ? null : originOrUrl.slice(0, pathIndex); if (originOrUrl && originOrUrl.slice(-4).toLowerCase() === ".swf") { return null; } return originOrUrl || null; }; /** * Set `allowScriptAccess` based on `trustedDomains` and `window.location.host` vs. `swfPath`. * * @returns The appropriate script access level. * @private */ var _determineScriptAccess = function() { var _extractAllDomains = function(origins) { var i, len, tmp, resultsArray = []; if (typeof origins === "string") { origins = [ origins ]; } if (!(typeof origins === "object" && origins && typeof origins.length === "number")) { return resultsArray; } for (i = 0, len = origins.length; i < len; i++) { if (_hasOwn.call(origins, i) && (tmp = _extractDomain(origins[i]))) { if (tmp === "*") { resultsArray.length = 0; resultsArray.push("*"); break; } if (resultsArray.indexOf(tmp) === -1) { resultsArray.push(tmp); } } } return resultsArray; }; return function(currentDomain, configOptions) { var swfDomain = _extractDomain(configOptions.swfPath); if (swfDomain === null) { swfDomain = currentDomain; } var trustedDomains = _extractAllDomains(configOptions.trustedDomains); var len = trustedDomains.length; if (len > 0) { if (len === 1 && trustedDomains[0] === "*") { return "always"; } if (trustedDomains.indexOf(currentDomain) !== -1) { if (len === 1 && currentDomain === swfDomain) { return "sameDomain"; } return "always"; } } return "never"; }; }(); /** * Get the currently active/focused DOM element. * * @returns the currently active/focused element, or `null` * @private */ var _safeActiveElement = function() { try { return _document.activeElement; } catch (err) { return null; } }; /** * Add a class to an element, if it doesn't already have it. * * @returns The element, with its new class added. * @private */ var _addClass = function(element, value) { var c, cl, className, classNames = []; if (typeof value === "string" && value) { classNames = value.split(/\s+/); } if (element && element.nodeType === 1 && classNames.length > 0) { className = (" " + (element.className || "") + " ").replace(/[\t\r\n\f]/g, " "); for (c = 0, cl = classNames.length; c < cl; c++) { if (className.indexOf(" " + classNames[c] + " ") === -1) { className += classNames[c] + " "; } } className = className.replace(/^\s+|\s+$/g, ""); if (className !== element.className) { element.className = className; } } return element; }; /** * Remove a class from an element, if it has it. * * @returns The element, with its class removed. * @private */ var _removeClass = function(element, value) { var c, cl, className, classNames = []; if (typeof value === "string" && value) { classNames = value.split(/\s+/); } if (element && element.nodeType === 1 && classNames.length > 0) { if (element.className) { className = (" " + element.className + " ").replace(/[\t\r\n\f]/g, " "); for (c = 0, cl = classNames.length; c < cl; c++) { className = className.replace(" " + classNames[c] + " ", " "); } className = className.replace(/^\s+|\s+$/g, ""); if (className !== element.className) { element.className = className; } } } return element; }; /** * Attempt to interpret the element's CSS styling. If `prop` is `"cursor"`, * then we assume that it should be a hand ("pointer") cursor if the element * is an anchor element ("a" tag). * * @returns The computed style property. * @private */ var _getStyle = function(el, prop) { var value = _getComputedStyle(el, null).getPropertyValue(prop); if (prop === "cursor") { if (!value || value === "auto") { if (el.nodeName === "A") { return "pointer"; } } } return value; }; /** * Get the absolutely positioned coordinates of a DOM element. * * @returns Object containing the element's position, width, and height. * @private */ var _getElementPosition = function(el) { var pos = { left: 0, top: 0, width: 0, height: 0 }; if (el.getBoundingClientRect) { var elRect = el.getBoundingClientRect(); var pageXOffset = _window.pageXOffset; var pageYOffset = _window.pageYOffset; var leftBorderWidth = _document.documentElement.clientLeft || 0; var topBorderWidth = _document.documentElement.clientTop || 0; var leftBodyOffset = 0; var topBodyOffset = 0; if (_getStyle(_document.body, "position") === "relative") { var bodyRect = _document.body.getBoundingClientRect(); var htmlRect = _document.documentElement.getBoundingClientRect(); leftBodyOffset = bodyRect.left - htmlRect.left || 0; topBodyOffset = bodyRect.top - htmlRect.top || 0; } pos.left = elRect.left + pageXOffset - leftBorderWidth - leftBodyOffset; pos.top = elRect.top + pageYOffset - topBorderWidth - topBodyOffset; pos.width = "width" in elRect ? elRect.width : elRect.right - elRect.left; pos.height = "height" in elRect ? elRect.height : elRect.bottom - elRect.top; } return pos; }; /** * Determine is an element is visible somewhere within the document (page). * * @returns Boolean * @private */ var _isElementVisible = function(el) { if (!el) { return false; } var styles = _getComputedStyle(el, null); if (!styles) { return false; } var hasCssHeight = _parseFloat(styles.height) > 0; var hasCssWidth = _parseFloat(styles.width) > 0; var hasCssTop = _parseFloat(styles.top) >= 0; var hasCssLeft = _parseFloat(styles.left) >= 0; var cssKnows = hasCssHeight && hasCssWidth && hasCssTop && hasCssLeft; var rect = cssKnows ? null : _getElementPosition(el); var isVisible = styles.display !== "none" && styles.visibility !== "collapse" && (cssKnows || !!rect && (hasCssHeight || rect.height > 0) && (hasCssWidth || rect.width > 0) && (hasCssTop || rect.top >= 0) && (hasCssLeft || rect.left >= 0)); return isVisible; }; /** * Clear all existing timeouts and interval polling delegates. * * @returns `undefined` * @private */ var _clearTimeoutsAndPolling = function() { _clearTimeout(_flashCheckTimeout); _flashCheckTimeout = 0; _clearInterval(_swfFallbackCheckInterval); _swfFallbackCheckInterval = 0; }; /** * Reposition the Flash object to cover the currently activated element. * * @returns `undefined` * @private */ var _reposition = function() { var htmlBridge; if (_currentElement && (htmlBridge = _getHtmlBridge(_flashState.bridge))) { var pos = _getElementPosition(_currentElement); _extend(htmlBridge.style, { width: pos.width + "px", height: pos.height + "px", top: pos.top + "px", left: pos.left + "px", zIndex: "" + _getSafeZIndex(_globalConfig.zIndex) }); } }; /** * Sends a signal to the Flash object to display the hand cursor if `true`. * * @returns `undefined` * @private */ var _setHandCursor = function(enabled) { if (_flashState.ready === true) { if (_flashState.bridge && typeof _flashState.bridge.setHandCursor === "function") { _flashState.bridge.setHandCursor(enabled); } else { _flashState.ready = false; } } }; /** * Get a safe value for `zIndex` * * @returns an integer, or "auto" * @private */ var _getSafeZIndex = function(val) { if (/^(?:auto|inherit)$/.test(val)) { return val; } var zIndex; if (typeof val === "number" && !_isNaN(val)) { zIndex = val; } else if (typeof val === "string") { zIndex = _getSafeZIndex(_parseInt(val, 10)); } return typeof zIndex === "number" ? zIndex : "auto"; }; /** * Ensure OS-compliant line endings, i.e. "\r\n" on Windows, "\n" elsewhere * * @returns string * @private */ var _fixLineEndings = function(content) { var replaceRegex = /(\r\n|\r|\n)/g; if (typeof content === "string" && _globalConfig.fixLineEndings === true) { if (_isWindows()) { if (/((^|[^\r])\n|\r([^\n]|$))/.test(content)) { content = content.replace(replaceRegex, "\r\n"); } } else if (/\r/.test(content)) { content = content.replace(replaceRegex, "\n"); } } return content; }; /** * Attempt to detect if ZeroClipboard is executing inside of a sandboxed iframe. * If it is, Flash Player cannot be used, so ZeroClipboard is dead in the water. * * @see {@link http://lists.w3.org/Archives/Public/public-whatwg-archive/2014Dec/0002.html} * @see {@link https://github.com/zeroclipboard/zeroclipboard/issues/511} * @see {@link http://zeroclipboard.org/test-iframes.html} * * @returns `true` (is sandboxed), `false` (is not sandboxed), or `null` (uncertain) * @private */ var _detectSandbox = function(doNotReassessFlashSupport) { var effectiveScriptOrigin, frame, frameError, previousState = _flashState.sandboxed, isSandboxed = null; doNotReassessFlashSupport = doNotReassessFlashSupport === true; if (_pageIsFramed === false) { isSandboxed = false; } else { try { frame = window.frameElement || null; } catch (e) { frameError = { name: e.name, message: e.message }; } if (frame && frame.nodeType === 1 && frame.nodeName === "IFRAME") { try { isSandboxed = frame.hasAttribute("sandbox"); } catch (e) { isSandboxed = null; } } else { try { effectiveScriptOrigin = document.domain || null; } catch (e) { effectiveScriptOrigin = null; } if (effectiveScriptOrigin === null || frameError && frameError.name === "SecurityError" && /(^|[\s\(\[@])sandbox(es|ed|ing|[\s\.,!\)\]@]|$)/.test(frameError.message.toLowerCase())) { isSandboxed = true; } } } _flashState.sandboxed = isSandboxed; if (previousState !== isSandboxed && !doNotReassessFlashSupport) { _detectFlashSupport(_ActiveXObject); } return isSandboxed; }; /** * Detect the Flash Player status, version, and plugin type. * * @see {@link https://code.google.com/p/doctype-mirror/wiki/ArticleDetectFlash#The_code} * @see {@link http://stackoverflow.com/questions/12866060/detecting-pepper-ppapi-flash-with-javascript} * * @returns `undefined` * @private */ var _detectFlashSupport = function(ActiveXObject) { var plugin, ax, mimeType, hasFlash = false, isActiveX = false, isPPAPI = false, flashVersion = ""; /** * Derived from Apple's suggested sniffer. * @param {String} desc e.g. "Shockwave Flash 7.0 r61" * @returns {String} "7.0.61" * @private */ function parseFlashVersion(desc) { var matches = desc.match(/[\d]+/g); matches.length = 3; return matches.join("."); } function isPepperFlash(flashPlayerFileName) { return !!flashPlayerFileName && (flashPlayerFileName = flashPlayerFileName.toLowerCase()) && (/^(pepflashplayer\.dll|libpepflashplayer\.so|pepperflashplayer\.plugin)$/.test(flashPlayerFileName) || flashPlayerFileName.slice(-13) === "chrome.plugin"); } function inspectPlugin(plugin) { if (plugin) { hasFlash = true; if (plugin.version) { flashVersion = parseFlashVersion(plugin.version); } if (!flashVersion && plugin.description) { flashVersion = parseFlashVersion(plugin.description); } if (plugin.filename) { isPPAPI = isPepperFlash(plugin.filename); } } } if (_navigator.plugins && _navigator.plugins.length) { plugin = _navigator.plugins["Shockwave Flash"]; inspectPlugin(plugin); if (_navigator.plugins["Shockwave Flash 2.0"]) { hasFlash = true; flashVersion = "2.0.0.11"; } } else if (_navigator.mimeTypes && _navigator.mimeTypes.length) { mimeType = _navigator.mimeTypes["application/x-shockwave-flash"]; plugin = mimeType && mimeType.enabledPlugin; inspectPlugin(plugin); } else if (typeof ActiveXObject !== "undefined") { isActiveX = true; try { ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.7"); hasFlash = true; flashVersion = parseFlashVersion(ax.GetVariable("$version")); } catch (e1) { try { ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash.6"); hasFlash = true; flashVersion = "6.0.21"; } catch (e2) { try { ax = new ActiveXObject("ShockwaveFlash.ShockwaveFlash"); hasFlash = true; flashVersion = parseFlashVersion(ax.GetVariable("$version")); } catch (e3) { isActiveX = false; } } } } _flashState.disabled = hasFlash !== true; _flashState.outdated = flashVersion && _parseFloat(flashVersion) < _parseFloat(_minimumFlashVersion); _flashState.version = flashVersion || "0.0.0"; _flashState.pluginType = isPPAPI ? "pepper" : isActiveX ? "activex" : hasFlash ? "netscape" : "unknown"; }; /** * Invoke the Flash detection algorithms immediately upon inclusion so we're not waiting later. */ _detectFlashSupport(_ActiveXObject); /** * Always assess the `sandboxed` state of the page at important Flash-related moments. */ _detectSandbox(true); /** * A shell constructor for `ZeroClipboard` client instances. * * @constructor */ var ZeroClipboard = function() { if (!(this instanceof ZeroClipboard)) { return new ZeroClipboard(); } if (typeof ZeroClipboard._createClient === "function") { ZeroClipboard._createClient.apply(this, _args(arguments)); } }; /** * The ZeroClipboard library's version number. * * @static * @readonly * @property {string} */ _defineProperty(ZeroClipboard, "version", { value: "2.3.0-beta.1", writable: false, configurable: true, enumerable: true }); /** * Update or get a copy of the ZeroClipboard global configuration. * Returns a copy of the current/updated configuration. * * @returns Object * @static */ ZeroClipboard.config = function() { return _config.apply(this, _args(arguments)); }; /** * Diagnostic method that describes the state of the browser, Flash Player, and ZeroClipboard. * * @returns Object * @static */ ZeroClipboard.state = function() { return _state.apply(this, _args(arguments)); }; /** * Check if Flash is unusable for any reason: disabled, outdated, deactivated, etc. * * @returns Boolean * @static */ ZeroClipboard.isFlashUnusable = function() { return _isFlashUnusable.apply(this, _args(arguments)); }; /** * Register an event listener. * * @returns `ZeroClipboard` * @static */ ZeroClipboard.on = function() { return _on.apply(this, _args(arguments)); }; /** * Unregister an event listener. * If no `listener` function/object is provided, it will unregister all listeners for the provided `eventType`. * If no `eventType` is provided, it will unregister all listeners for every event type. * * @returns `ZeroClipboard` * @static */ ZeroClipboard.off = function() { return _off.apply(this, _args(arguments)); }; /** * Retrieve event listeners for an `eventType`. * If no `eventType` is provided, it will retrieve all listeners for every event type. * * @returns array of listeners for the `eventType`; if no `eventType`, then a map/hash object of listeners for all event types; or `null` */ ZeroClipboard.handlers = function() { return _listeners.apply(this, _args(arguments)); }; /** * Event emission receiver from the Flash object, forwarding to any registered JavaScript event listeners. * * @returns For the "copy" event, returns the Flash-friendly "clipData" object; otherwise `undefined`. * @static */ ZeroClipboard.emit = function() { return _emit.apply(this, _args(arguments)); }; /** * Create and embed the Flash object. * * @returns The Flash object * @static */ ZeroClipboard.create = function() { return _create.apply(this, _args(arguments)); }; /** * Self-destruct and clean up everything, including the embedded Flash object. * * @returns `undefined` * @static */ ZeroClipboard.destroy = function() { return _destroy.apply(this, _args(arguments)); }; /** * Set the pending data for clipboard injection. * * @returns `undefined` * @static */ ZeroClipboard.setData = function() { return _setData.apply(this, _args(arguments)); }; /** * Clear the pending data for clipboard injection. * If no `format` is provided, all pending data formats will be cleared. * * @returns `undefined` * @static */ ZeroClipboard.clearData = function() { return _clearData.apply(this, _args(arguments)); }; /** * Get a copy of the pending data for clipboard injection. * If no `format` is provided, a copy of ALL pending data formats will be returned. * * @returns `String` or `Object` * @static */ ZeroClipboard.getData = function() { return _getData.apply(this, _args(arguments)); }; /** * Sets the current HTML object that the Flash object should overlay. This will put the global * Flash object on top of the current element; depending on the setup, this may also set the * pending clipboard text data as well as the Flash object's wrapping element's title attribute * based on the underlying HTML element and ZeroClipboard configuration. * * @returns `undefined` * @static */ ZeroClipboard.focus = ZeroClipboard.activate = function() { return _focus.apply(this, _args(arguments)); }; /** * Un-overlays the Flash object. This will put the global Flash object off-screen; depending on * the setup, this may also unset the Flash object's wrapping element's title attribute based on * the underlying HTML element and ZeroClipboard configuration. * * @returns `undefined` * @static */ ZeroClipboard.blur = ZeroClipboard.deactivate = function() { return _blur.apply(this, _args(arguments)); }; /** * Returns the currently focused/"activated" HTML element that the Flash object is wrapping. * * @returns `HTMLElement` or `null` * @static */ ZeroClipboard.activeElement = function() { return _activeElement.apply(this, _args(arguments)); }; /** * Keep track of the ZeroClipboard client instance counter. */ var _clientIdCounter = 0; /** * Keep track of the state of the client instances. * * Entry structure: * _clientMeta[client.id] = { * instance: client, * elements: [], * handlers: {} * }; */ var _clientMeta = {}; /** * Keep track of the ZeroClipboard clipped elements counter. */ var _elementIdCounter = 0; /** * Keep track of the state of the clipped element relationships to clients. * * Entry structure: * _elementMeta[element.zcClippingId] = [client1.id, client2.id]; */ var _elementMeta = {}; /** * Keep track of the state of the mouse event handlers for clipped elements. * * Entry structure: * _mouseHandlers[element.zcClippingId] = { * mouseover: function(event) {}, * mouseout: function(event) {}, * mouseenter: function(event) {}, * mouseleave: function(event) {}, * mousemove: function(event) {} * }; */ var _mouseHandlers = {}; /** * Extending the ZeroClipboard configuration defaults for the Client module. */ _extend(_globalConfig, { autoActivate: true }); /** * The real constructor for `ZeroClipboard` client instances. * @private */ var _clientConstructor = function(elements) { var client = this; client.id = "" + _clientIdCounter++; _clientMeta[client.id] = { instance: client, elements: [], handlers: {} }; if (elements) { client.clip(elements); } ZeroClipboard.on("*", function(event) { return client.emit(event); }); ZeroClipboard.on("destroy", function() { client.destroy(); }); ZeroClipboard.create(); }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.on`. * @private */ var _clientOn = function(eventType, listener) { var i, len, events, added = {}, meta = _clientMeta[this.id], handlers = meta && meta.handlers; if (!meta) { throw new Error("Attempted to add new listener(s) to a destroyed ZeroClipboard client instance"); } if (typeof eventType === "string" && eventType) { events = eventType.toLowerCase().split(/\s+/); } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") { for (i in eventType) { if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") { this.on(i, eventType[i]); } } } if (events && events.length) { for (i = 0, len = events.length; i < len; i++) { eventType = events[i].replace(/^on/, ""); added[eventType] = true; if (!handlers[eventType]) { handlers[eventType] = []; } handlers[eventType].push(listener); } if (added.ready && _flashState.ready) { this.emit({ type: "ready", client: this }); } if (added.error) { for (i = 0, len = _flashStateErrorNames.length; i < len; i++) { if (_flashState[_flashStateErrorNames[i].replace(/^flash-/, "")]) { this.emit({ type: "error", name: _flashStateErrorNames[i], client: this }); break; } } if (_zcSwfVersion !== undefined && ZeroClipboard.version !== _zcSwfVersion) { this.emit({ type: "error", name: "version-mismatch", jsVersion: ZeroClipboard.version, swfVersion: _zcSwfVersion }); } } } return this; }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.off`. * @private */ var _clientOff = function(eventType, listener) { var i, len, foundIndex, events, perEventHandlers, meta = _clientMeta[this.id], handlers = meta && meta.handlers; if (!handlers) { return this; } if (arguments.length === 0) { events = _keys(handlers); } else if (typeof eventType === "string" && eventType) { events = eventType.split(/\s+/); } else if (typeof eventType === "object" && eventType && typeof listener === "undefined") { for (i in eventType) { if (_hasOwn.call(eventType, i) && typeof i === "string" && i && typeof eventType[i] === "function") { this.off(i, eventType[i]); } } } if (events && events.length) { for (i = 0, len = events.length; i < len; i++) { eventType = events[i].toLowerCase().replace(/^on/, ""); perEventHandlers = handlers[eventType]; if (perEventHandlers && perEventHandlers.length) { if (listener) { foundIndex = perEventHandlers.indexOf(listener); while (foundIndex !== -1) { perEventHandlers.splice(foundIndex, 1); foundIndex = perEventHandlers.indexOf(listener, foundIndex); } } else { perEventHandlers.length = 0; } } } } return this; }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.handlers`. * @private */ var _clientListeners = function(eventType) { var copy = null, handlers = _clientMeta[this.id] && _clientMeta[this.id].handlers; if (handlers) { if (typeof eventType === "string" && eventType) { copy = handlers[eventType] ? handlers[eventType].slice(0) : []; } else { copy = _deepCopy(handlers); } } return copy; }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.emit`. * @private */ var _clientEmit = function(event) { if (_clientShouldEmit.call(this, event)) { if (typeof event === "object" && event && typeof event.type === "string" && event.type) { event = _extend({}, event); } var eventCopy = _extend({}, _createEvent(event), { client: this }); _clientDispatchCallbacks.call(this, eventCopy); } return this; }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.clip`. * @private */ var _clientClip = function(elements) { if (!_clientMeta[this.id]) { throw new Error("Attempted to clip element(s) to a destroyed ZeroClipboard client instance"); } elements = _prepClip(elements); for (var i = 0; i < elements.length; i++) { if (_hasOwn.call(elements, i) && elements[i] && elements[i].nodeType === 1) { if (!elements[i].zcClippingId) { elements[i].zcClippingId = "zcClippingId_" + _elementIdCounter++; _elementMeta[elements[i].zcClippingId] = [ this.id ]; if (_globalConfig.autoActivate === true) { _addMouseHandlers(elements[i]); } } else if (_elementMeta[elements[i].zcClippingId].indexOf(this.id) === -1) { _elementMeta[elements[i].zcClippingId].push(this.id); } var clippedElements = _clientMeta[this.id] && _clientMeta[this.id].elements; if (clippedElements.indexOf(elements[i]) === -1) { clippedElements.push(elements[i]); } } } return this; }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.unclip`. * @private */ var _clientUnclip = function(elements) { var meta = _clientMeta[this.id]; if (!meta) { return this; } var clippedElements = meta.elements; var arrayIndex; if (typeof elements === "undefined") { elements = clippedElements.slice(0); } else { elements = _prepClip(elements); } for (var i = elements.length; i--; ) { if (_hasOwn.call(elements, i) && elements[i] && elements[i].nodeType === 1) { arrayIndex = 0; while ((arrayIndex = clippedElements.indexOf(elements[i], arrayIndex)) !== -1) { clippedElements.splice(arrayIndex, 1); } var clientIds = _elementMeta[elements[i].zcClippingId]; if (clientIds) { arrayIndex = 0; while ((arrayIndex = clientIds.indexOf(this.id, arrayIndex)) !== -1) { clientIds.splice(arrayIndex, 1); } if (clientIds.length === 0) { if (_globalConfig.autoActivate === true) { _removeMouseHandlers(elements[i]); } delete elements[i].zcClippingId; } } } } return this; }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.elements`. * @private */ var _clientElements = function() { var meta = _clientMeta[this.id]; return meta && meta.elements ? meta.elements.slice(0) : []; }; /** * The underlying implementation of `ZeroClipboard.Client.prototype.destroy`. * @private */ var _clientDestroy = function() { if (!_clientMeta[this.id]) { return; } this.unclip(); this.off(); delete _clientMeta[this.id]; }; /** * Inspect an Event to see if the Client (`this`) should honor it for emission. * @private */ var _clientShouldEmit = function(event) { if (!(event && event.type)) { return false; } if (event.client && event.client !== this) { return false; } var meta = _clientMeta[this.id]; var clippedEls = meta && meta.elements; var hasClippedEls = !!clippedEls && clippedEls.length > 0; var goodTarget = !event.target || hasClippedEls && clippedEls.indexOf(event.target) !== -1; var goodRelTarget = event.relatedTarget && hasClippedEls && clippedEls.indexOf(event.relatedTarget) !== -1; var goodClient = event.client && event.client === this; if (!meta || !(goodTarget || goodRelTarget || goodClient)) { return false; } return true; }; /** * Handle the actual dispatching of events to a client instance. * * @returns `undefined` * @private */ var _clientDispatchCallbacks = function(event) { var meta = _clientMeta[this.id]; if (!(typeof event === "object" && event && event.type && meta)) { return; } var async = _shouldPerformAsync(event); var wildcardTypeHandlers = meta && meta.handlers["*"] || []; var specificTypeHandlers = meta && meta.handlers[event.type] || []; var handlers = wildcardTypeHandlers.concat(specificTypeHandlers); if (handlers && handlers.length) { var i, len, func, context, eventCopy, originalContext = this; for (i = 0, len = handlers.length; i < len; i++) { func = handlers[i]; context = originalContext; if (typeof func === "string" && typeof _window[func] === "function") { func = _window[func]; } if (typeof func === "object" && func && typeof func.handleEvent === "function") { context = func; func = func.handleEvent; } if (typeof func === "function") { eventCopy = _extend({}, event); _dispatchCallback(func, context, [ eventCopy ], async); } } } }; /** * Prepares the elements for clipping/unclipping. * * @returns An Array of elements. * @private */ var _prepClip = function(elements) { if (typeof elements === "string") { elements = []; } return typeof elements.length !== "number" ? [ elements ] : elements; }; /** * Add a `mouseover` handler function for a clipped element. * * @returns `undefined` * @private */ var _addMouseHandlers = function(element) { if (!(element && element.nodeType === 1)) { return; } var _suppressMouseEvents = function(event) { if (!(event || (event = _window.event))) { return; } if (event._source !== "js") { event.stopImmediatePropagation(); event.preventDefault(); } delete event._source; }; var _elementMouseOver = function(event) { if (!(event || (event = _window.event))) { return; } _suppressMouseEvents(event); ZeroClipboard.focus(element); }; element.addEventListener("mouseover", _elementMouseOver, false); element.addEventListener("mouseout", _suppressMouseEvents, false); element.addEventListener("mouseenter", _suppressMouseEvents, false); element.addEventListener("mouseleave", _suppressMouseEvents, false); element.addEventListener("mousemove", _suppressMouseEvents, false); _mouseHandlers[element.zcClippingId] = { mouseover: _elementMouseOver, mouseout: _suppressMouseEvents, mouseenter: _suppressMouseEvents, mouseleave: _suppressMouseEvents, mousemove: _suppressMouseEvents }; }; /** * Remove a `mouseover` handler function for a clipped element. * * @returns `undefined` * @private */ var _removeMouseHandlers = function(element) { if (!(element && element.nodeType === 1)) { return; } var mouseHandlers = _mouseHandlers[element.zcClippingId]; if (!(typeof mouseHandlers === "object" && mouseHandlers)) { return; } var key, val, mouseEvents = [ "move", "leave", "enter", "out", "over" ]; for (var i = 0, len = mouseEvents.length; i < len; i++) { key = "mouse" + mouseEvents[i]; val = mouseHandlers[key]; if (typeof val === "function") { element.removeEventListener(key, val, false); } } delete _mouseHandlers[element.zcClippingId]; }; /** * Creates a new ZeroClipboard client instance. * Optionally, auto-`clip` an element or collection of elements. * * @constructor */ ZeroClipboard._createClient = function() { _clientConstructor.apply(this, _args(arguments)); }; /** * Register an event listener to the client. * * @returns `this` */ ZeroClipboard.prototype.on = function() { return _clientOn.apply(this, _args(arguments)); }; /** * Unregister an event handler from the client. * If no `listener` function/object is provided, it will unregister all handlers for the provided `eventType`. * If no `eventType` is provided, it will unregister all handlers for every event type. * * @returns `this` */ ZeroClipboard.prototype.off = function() { return _clientOff.apply(this, _args(arguments)); }; /** * Retrieve event listeners for an `eventType` from the client. * If no `eventType` is provided, it will retrieve all listeners for every event type. * * @returns array of listeners for the `eventType`; if no `eventType`, then a map/hash object of listeners for all event types; or `null` */ ZeroClipboard.prototype.handlers = function() { return _clientListeners.apply(this, _args(arguments)); }; /** * Event emission receiver from the Flash object for this client's registered JavaScript event listeners. * * @returns For the "copy" event, returns the Flash-friendly "clipData" object; otherwise `undefined`. */ ZeroClipboard.prototype.emit = function() { return _clientEmit.apply(this, _args(arguments)); }; /** * Register clipboard actions for new element(s) to the client. * * @returns `this` */ ZeroClipboard.prototype.clip = function() { return _clientClip.apply(this, _args(arguments)); }; /** * Unregister the clipboard actions of previously registered element(s) on the page. * If no elements are provided, ALL registered elements will be unregistered. * * @returns `this` */ ZeroClipboard.prototype.unclip = function() { return _clientUnclip.apply(this, _args(arguments)); }; /** * Get all of the elements to which this client is clipped. * * @returns array of clipped elements */ ZeroClipboard.prototype.elements = function() { return _clientElements.apply(this, _args(arguments)); }; /** * Self-destruct and clean up everything for a single client. * This will NOT destroy the embedded Flash object. * * @returns `undefined` */ ZeroClipboard.prototype.destroy = function() { return _clientDestroy.apply(this, _args(arguments)); }; /** * Stores the pending plain text to inject into the clipboard. * * @returns `this` */ ZeroClipboard.prototype.setText = function(text) { if (!_clientMeta[this.id]) { throw new Error("Attempted to set pending clipboard data from a destroyed ZeroClipboard client instance"); } ZeroClipboard.setData("text/plain", text); return this; }; /** * Stores the pending HTML text to inject into the clipboard. * * @returns `this` */ ZeroClipboard.prototype.setHtml = function(html) { if (!_clientMeta[this.id]) { throw new Error("Attempted to set pending clipboard data from a destroyed ZeroClipboard client instance"); } ZeroClipboard.setData("text/html", html); return this; }; /** * Stores the pending rich text (RTF) to inject into the clipboard. * * @returns `this` */ ZeroClipboard.prototype.setRichText = function(richText) { if (!_clientMeta[this.id]) { throw new Error("Attempted to set pending clipboard data from a destroyed ZeroClipboard client instance"); } ZeroClipboard.setData("application/rtf", richText); return this; }; /** * Stores the pending data to inject into the clipboard. * * @returns `this` */ ZeroClipboard.prototype.setData = function() { if (!_clientMeta[this.id]) { throw new Error("Attempted to set pending clipboard data from a destroyed ZeroClipboard client instance"); } ZeroClipboard.setData.apply(this, _args(arguments)); return this; }; /** * Clears the pending data to inject into the clipboard. * If no `format` is provided, all pending data formats will be cleared. * * @returns `this` */ ZeroClipboard.prototype.clearData = function() { if (!_clientMeta[this.id]) { throw new Error("Attempted to clear pending clipboard data from a destroyed ZeroClipboard client instance"); } ZeroClipboard.clearData.apply(this, _args(arguments)); return this; }; /** * Gets a copy of the pending data to inject into the clipboard. * If no `format` is provided, a copy of ALL pending data formats will be returned. * * @returns `String` or `Object` */ ZeroClipboard.prototype.getData = function() { if (!_clientMeta[this.id]) { throw new Error("Attempted to get pending clipboard data from a destroyed ZeroClipboard client instance"); } return ZeroClipboard.getData.apply(this, _args(arguments)); }; if (typeof define === "function" && define.amd) { define(function() { return ZeroClipboard; }); } else if (typeof module === "object" && module && typeof module.exports === "object" && module.exports) { module.exports = ZeroClipboard; } else { window.ZeroClipboard = ZeroClipboard; } })(function() { return this || window; }());"
]
}