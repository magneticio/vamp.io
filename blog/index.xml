<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Vamp :: The Very Awesome Microservices Platform</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://vamp.io/blog/</link>
    <language>en-us</language>
    
    <updated> May 23, 2016</updated>
    
    
    <item>
      <title>Magnetic.io VAMP raises €500K in round led by Volta Ventures to deliver opensource canary testing and releasing solution for container and microservice systems</title>
      <link>http://vamp.io/2016/05/magnetic_io-vamp-raises-500k-in-investmentround-led-by-voltaventures/</link>
      <pubDate>Mon, 23 May 2016 00:00:00 UTC</pubDate>
      
      <guid>http://vamp.io/2016/05/magnetic_io-vamp-raises-500k-in-investmentround-led-by-voltaventures/</guid>
      <description>&lt;p&gt;&lt;strong&gt;DevOps and business teams use VAMP to reduce downtime, improve time-to-market and increase performance of online software.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AMSTERDAM, May 23, 2016&lt;/strong&gt; — Magnetic.io, an Amsterdam-based hi-tech startup that develops opensource solution VAMP (&lt;a href=&#34;http://vamp.io&#34;&gt;http://vamp.io&lt;/a&gt;), today announced that it has raised € 500,000 in a round led by Volta Ventures.
VAMP adds powerful canary testing and releasing, and autoscaling features to (Docker) container and microservice based systems. These features enable DevOps teams to deliver higher quality software in a shorter time. The investment will fuel the development of VAMP’s enterprise-grade features, grow the opensource community and partner network, and boost international expansion. Existing investor Startupbootcamp (SBC) and successful entrepreneur Henri de Jong (Mijndomein) will also participate in the round. Mr. Maene, Volta Ventures’ managing partner, will join the board of directors. &lt;/p&gt;

&lt;p&gt;To solve scaling, performance and time-to-market challenges, digital-savvy organisations are quickly adopting strategies like continuous-delivery, containers and microservices. To unlock the full potential of these technologies to both IT and business, VAMP adds an &amp;ldquo;experiment system&amp;rdquo; with canary and autoscaling features that make it safe, fast and easy to release, test and scale new software versions in production. &lt;/p&gt;

&lt;p&gt;Successful online companies like Netflix, AirBnB and Facebook have already demonstrated the power of canary testing and releasing. New versions of software are continually released in production to small percentages of visitors, performance is measured and improved, and the number of allowed visitors is gradually increased to achieve a risk-free and stable full release.&lt;/p&gt;

&lt;p&gt;Until recently, it was complex and expensive to apply these canary test and release methods. With VAMP it becomes straightforward and cost effective to add these features to both new or existing architectures. VAMP can work standalone or integrate with container systems like Docker, Mesosphere DC/OS, Azure Container Service, Rancher and Kubernetes.&lt;/p&gt;

&lt;p&gt;Frank Maene, managing partner Volta Ventures: &lt;em&gt;“We like the vision Olaf and his team have on the value add of VAMP in the burgeoning containers and microservices market. We believe VAMP will play an important role in enabling smarter ways of testing, delivering and scaling online software and containers, and we are excited to become a partner of the VAMP team and help to make this happen.”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Olaf Molenveld, Magnetic.io CEO and co-founder: &lt;em&gt;“We are very excited to have Volta Ventures, Henri de Jong and SBC on board in our mission to help organisations test, deliver and scale software in a smarter and more effective way. The experience and track-record available in this extended team is huge. It will help us to accelerate the product, the company and the opensource community adoption and we are very much looking forward to work together!”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;To start working with VAMP’s Canary and autoscaling features, download the free opensource version of VAMP from &lt;a href=&#34;http://vamp.io&#34;&gt;http://vamp.io&lt;/a&gt;. An easy-to-install QuickStart package is available to start working with VAMP within 5 minutes. For information about enterprise features please email info@magnetic.io&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;About Magnetic.io&lt;/strong&gt;&lt;br /&gt;
Magnetic.io’s VAMP is an open source platform that provides features for (A/B) testing, deploying and autoscaling (micro)service oriented architectures that rely on container technology.
The company is headquartered in Amsterdam and was created by Olaf Molenveld.
www.vamp.io&lt;/p&gt;

&lt;p&gt;Contact: Olaf Molenveld, CEO,&lt;br /&gt;
olaf@magnetic.io, tel +31 653 36 27 83&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;About Volta Ventures&lt;/strong&gt;&lt;br /&gt;
Volta Ventures Arkiv invests in young and ambitious internet and software companies in the Benelux. The fund has € 55 million under management and is supported by EIF and ARKimedes-Fund II.
www.volta.ventures&lt;/p&gt;

&lt;p&gt;Contact: Frank Maene, managing partner,&lt;br /&gt;
frank@voltaventures.eu, tel. +32 477 20 17 82&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;About Startupbootcamp&lt;/strong&gt;&lt;br /&gt;
Startupbootcamp started in 2010 and has grown into an international accelerator program for startups with 13 programs in Amsterdam, Barcelona, Berlin, Eindhoven, Istanbul, London, Miami, New York and Singapore. The mentor and alumni network is spread across more than 50 countries. More information can be found at: www.startupbootcamp.org&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Persbericht  - Magnetic.io VAMP haalt €500k op in investeringsronde geleid door Volta Ventures</title>
      <link>http://vamp.io/2016/05/magnetic_io-vamp-haalt-500k-op-in-investeringsronde-geleid-door-voltaventures/</link>
      <pubDate>Mon, 23 May 2016 00:00:00 UTC</pubDate>
      
      <guid>http://vamp.io/2016/05/magnetic_io-vamp-haalt-500k-op-in-investeringsronde-geleid-door-voltaventures/</guid>
      <description>

&lt;h3 id=&#34;magnetic-io-vamp-haalt-500k-op-in-investeringsronde-geleid-door-volta-ventures-om-opensource-canary-test-en-release-platform-voor-containers-en-microservices-op-te-schalen&#34;&gt;Magnetic.io VAMP haalt €500k op in investeringsronde geleid door Volta Ventures om opensource canary test en release platform voor containers en microservices op te schalen&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;DEVOPS EN BUSINESS TEAMS GEBRUIKEN VAMP OM STORINGEN TE VOORKOMEN, RELEASES TE VERSNELLEN, EN PERFORMANCE VAN ONLINE SOFTWARE TE OPTIMALISEREN.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AMSTERDAM, 23 Mei, 2016&lt;/strong&gt; — Magnetic.io, een in Amsterdam gevestigde hightech startup, heeft aangekondigd dat het een investering van €500.000 heeft opgehaald in een ronde geleid door Volta Ventures. Magnetic.io ontwikkelt VAMP, een opensource oplossing om canary-test en -release, en auto-scaling functionaliteiten, toe te voegen aan systemen die gebruik maken van populaire (Docker) container en microservice technologieën. De functionaliteiten die VAMP toevoegt maken het voor DevOps teams makkelijker om in minder tijd een hogere kwaliteit van online software in productie te brengen. De investering zal worden gebruikt voor de ontwikkeling van enterprise functionaliteiten voor het VAMP framework, het stimuleren en ondersteunen van de opensource community en het partner netwerk, en om de internationale groei te versnellen. Huidige investeerder Startupbootcamp (SBC) en succesvolle ondernemer Henri de Jong (Mijndomein) nemen ook deel in de investeringsronde. Dhr. Maene, managing partner van Volta Ventures, zal toetreden tot de raad van bestuur.&lt;/p&gt;

&lt;p&gt;Om uitdagingen op het gebied van online en digitale groei, performance en time-to-market op te lossen, passen steeds meer online organisaties technieken als continuous-delivery, containers en microservices toe. Om het volledige potentieel van deze technologieën te benutten, voor zowel IT als business, is een overkoepelend experimenteer-systeem zoals VAMP essentieel. Door alle onderliggende onderdelen slim te coördineren wordt het mogelijk om snel, eenvoudig en vooral risico-vrij continue nieuwe versies van online software naar productie uit te rollen, te testen, optimaliseren en op te schalen.&lt;/p&gt;

&lt;p&gt;Succesvolle online bedrijven zoals Netflix, AirBnB en Facebook passen deze “canary test en release” methode al jaren zeer succesvol toe. Zij lanceren vrijwel continue nieuwe versies en varianten van hun software naar kleine percentages bezoekers, meten en optimaliseren vervolgens de performance, en verhogen dan stapsgewijs het percentage bezoekers om zo op een risicovrije en gecontroleerde manier tot een stabiele en geoptimaliseerde upgrade te komen.&lt;/p&gt;

&lt;p&gt;Tot voor kort was het voor de meeste organisaties complex en duur om dit soort “canary methodieken” toe te passen. VAMP maakt het eenvoudig en kosteneffectief om deze slimme en veilige manier van online software in productie testen en upgraden toe te voegen aan bestaande en nieuwe architecturen. VAMP kan zowel stand-alone werken, als ook in combinatie met veelgebruikte container en microservices oplossingen zoals bijvoorbeeld Docker, Mesosphere DC/OS, Azure Container Service, Rancher en Kubernetes.&lt;/p&gt;

&lt;p&gt;Frank Maene, managing partner Volta Ventures:
&lt;em&gt;“Wij zijn overtuigd van de visie van Olaf en zijn team op de toegevoegde waarde van VAMP in een sterk groeiende container en microservices markt. Wij geloven dat VAMP een belangrijke rol zal spelen bij het mogelijk maken van het slimmer uitrollen, optimaliseren en schalen van online software en containers. Wij zijn enthousiast om hier deel van uit te maken en het VAMP team hierbij te ondersteunen.”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Olaf Molenveld, Magnetic.io CEO en co-founder:
&lt;em&gt;“We zijn zeer blij om Volta Ventures, Henri de Jong en SBC aan boord te hebben. Samen kunnen we onze missie om organisaties slimmer software te laten uitrollen, optimaliseren en schalen nog beter vorm geven. De ervaring waar we nu uit kunnen putten is zeer waardevol. Dit gaat ons absoluut helpen om ons product, het team en de opensource community verder te laten groeien.”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Om binnen 5 minuten met VAMP’s canary en auto-scaling functionaliteiten aan de slag te gaan is een eenvoudig te installeren QuickStart versie gratis te downloaden vanaf &lt;a href=&#34;http://vamp.io&#34;&gt;http://vamp.io&lt;/a&gt;. Voor informatie over de enterprise functionaliteiten en andere vragen stuur een email naar info@magnetic.io&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Over Magnetic.io&lt;/strong&gt;&lt;br /&gt;
Magnetic.io VAMP is het opensource platform dat slimme functionaliteiten voor (A/B) testen, uitrollen en automatisch schalen toevoegt aan (micro)service en container gebaseerde architecturen. Het bedrijf is gevestigd in Amsterdam en is mede opgericht door Olaf Molenveld
www.vamp.io&lt;/p&gt;

&lt;p&gt;Contact: Olaf Molenveld, CEO,&lt;br /&gt;
olaf@magnetic.io, tel +31 653 36 27 83&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Over Volta Ventures&lt;/strong&gt;&lt;br /&gt;
Volta Ventures Arkiv investeert in jonge en ambitieuze internetbedrijven in de Benelux. Het fonds heeft € 55 miljoen onder beheer en wordt ondersteund door het EIF en ARKimedes-Fonds II.
www.volta.ventures&lt;/p&gt;

&lt;p&gt;Contact: Frank Maene, managing partner,&lt;br /&gt;
frank@voltaventures.eu, tel. +32 477 20 17 82&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Over Startupbootcamp&lt;/strong&gt;&lt;br /&gt;
Startupbootcamp is opgericht in 2010 en is inmiddels uitgegroeid tot een internationaal accelerator programma voor startups met 13 programma&amp;rsquo;s in Amsterdam, Barcelona, ​​Berlijn, Eindhoven, Istanbul, Londen, Miami, New York en Singapore. Het mentor en alumni-netwerk is verspreid over meer dan 50 landen. Meer informatie is te vinden op: www.startupbootcamp.org&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Canaries and Containers - DC/OS and VAMP</title>
      <link>http://vamp.io/2016/04/canaries-and-containers/</link>
      <pubDate>Mon, 18 Apr 2016 00:00:00 UTC</pubDate>
      
      <guid>http://vamp.io/2016/04/canaries-and-containers/</guid>
      <description>

&lt;h2 id=&#34;what-do-canaries-and-containers-have-in-common&#34;&gt;&lt;strong&gt;&lt;em&gt;What do canaries and containers have in common?&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;With the advent of container-technology (developed by Google in their now famous Borg project and made wildly popular by companies like Docker and Mesosphere) innovative ways of deploying, running and (auto)scaling software like microservices become possible for everybody. But “with great power also comes great responsibility” and thus these new possibilities also need a new breed of tools to really leverage the benefits of container technology in real world production environments and scenarios.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://vamp.io/img/weight_sliders.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://dcos.io&#34;&gt;DC/OS&lt;/a&gt; and &lt;a href=&#34;http://vamp.io&#34;&gt;VAMP&lt;/a&gt; are such tools that help you make it easy to get the best out of using containers when you move away from “hello world” test-setups and into real world environments.&lt;/p&gt;

&lt;p&gt;To run containers in production environments, you will need a cluster manager. A single machine to run your containers on simply doesn’t give you the resilience you are aiming for. If a machine breaks down you want your containers to instantly, automatically and transparently be moved to other machines without your users experiencing any downtime. If you need more processing-power because of increased demand you want to be able to easily and quickly add machines to increase the pool of computing-resources that your containers can transparently make use of. This is where a container cluster-manager comes in.&lt;/p&gt;

&lt;p&gt;One of the most used and battle-hardened container cluster-managers out there is Mesos. Mesos is an Apache project that spun out of technology developed and used by AirBnB and Twitter. Mesosphere is the company that is one of the core contributors to Mesos and also packages Mesos into DC/OS (the Datacenter Operation System). DC/OS is a robust and commercially supported product that is built on top of Mesos and adds powerful features like command-line and web-interfaces, simple packaging and installation, and a growing ecosystem of frameworks that can run on top of it. Mesos and DC/OS are powering famous platforms like Apple Siri, Bloomberg, Paypal, but can also be very useful on (much) smaller clusters.&lt;/p&gt;

&lt;p&gt;An important feature of DC/OS is that it’s open-source. Opensource software these days is an important aspect of running trusted and hardened production systems and has become an important requirement for engineers and IT departments alike. We believe DC/OS is a great step forward in easing the transition to and adoption of containers and container-cluster managers in real world production environments.&lt;/p&gt;

&lt;p&gt;Because of the heritage of Mesos, DC/OS delivers a very compelling way to run containers in production. It’s opensource, easy to install, well documented, fully featured and solves real world problems with a growing ecosystem of integrated solutions and frameworks that are easy to install and experiment with.&lt;/p&gt;

&lt;h2 id=&#34;canary-testing-releasing-containers&#34;&gt;Canary testing &amp;amp; releasing containers&lt;/h2&gt;

&lt;p&gt;One of the most popular and essential frameworks for Mesos and DC/OS is Marathon. Marathon is a container-orchestration framework and is designed to manage long-running jobs. Long-running jobs in containers are typically web-oriented API’s, applications and microservices.&lt;/p&gt;

&lt;p&gt;While DC/OS and Marathon make it easy to deploy, run and orchestrate these containers, you need an additional “experiment framework” to enable a process of continuously measuring, improving and scaling your container-packaged software without negatively affecting your visitors or having downtime. We call this “Continuous Improvement” and this is where VAMP comes in.&lt;/p&gt;

&lt;p&gt;Companies like Facebook, Spotify and Netflix are very successfully using a pattern called Canary testing &amp;amp; releasing. It’s an advanced variant of blue-green releasing, where you seamlessly switch from the current to a new version of software without perceived downtime for your visitors. VAMP is an opensource framework that integrates with DC/OS and Marathon and delivers canary-testing &amp;amp; releasing and autoscaling features in an easy-to-use and powerful way.&lt;/p&gt;

&lt;p&gt;When deploying one or more new versions of your software in containers to production, VAMP enables you to expose these versions to only a small percentage of your visitors with specific criteria (a ‘bucket’ or ‘cohort’).&lt;/p&gt;

&lt;p&gt;You can now test and validate the technical and/or business performance of your new software versions in this limited setting but in production. This means you don’t need to over-optimise prematurely, and can detect and fix potential  issues before you move gradually to a full scale deployment.&lt;/p&gt;

&lt;p&gt;A typical real world use-case for canary-testing &amp;amp; releasing with VAMP and DC/OS is:&lt;/p&gt;

&lt;p&gt;Validating the performance of a new (e.g. responsive) website front-end by developing and optimising it only for Chrome-browsers first, exposing it to 5% of your visitors with Chrome-browsers (you could even do this for specific resolutions and devices), validating your hypothesis (e.g. better conversion and/or faster response times), fixing technical issues, and then scaling up to a higher percentage of visitors and/or gradually adding new browser-types until you reach a full deployment.&lt;/p&gt;

&lt;p&gt;With VAMP on DC/OS this can done by simply sending these rules to VAMP (either using our Graphical UI, command-line interface or directly to the REST API):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
 frontend_A: 
   weight: 100%
 frontend_B:
   weight: 0%
   filter_strength: 5%
   filters:
     - user-agent == Chrome
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Other use-cases are the validation and testing of different technological and architectural solutions (f.e. couchDB vs MongoDB as an embedded microservice datastore) in production and without impacting your visitors, or experimental finding of the optimal balance between allocated computing-resources (i.e. running costs) and the performance of your services.&lt;/p&gt;

&lt;p&gt;VAMP supports grouping of filters, Boolean expressions (AND/OR/NOT), and provides a built-in set of commonly used “routing short codes” like cookies, browser-types, headers and host-names in addition to supporting HAProxy ACL rules and configuration templates. VAMP also supports sticky sessions, URL path rewriting (very useful for API versioning, aggregation and routing) and makes sure that services are correctly “drained” when taken out of the routing.&lt;/p&gt;

&lt;h2 id=&#34;autoscaling&#34;&gt;Autoscaling&lt;/h2&gt;

&lt;p&gt;So now we know that VAMP makes it very easy to implement all kinds of useful canary-testing &amp;amp; releasing patterns. But when you are increasing the percentage of visitors or are expanding your filter-criteria to allow more visitors, you also need to scale up the number of running instances or allocated computing resources. Of course with Marathon it’s easy to use the UI or API to set the scale of the running containers. But wouldn’t it be much more practical if you could simply change the scaling-settings at the same time when changing the routing and load-balancing rules? Or even cooler: change the scaling automatically, based on performance-criteria? We thought so too, so we made it easy to do with VAMP:&lt;/p&gt;

&lt;p&gt;In VAMP you can set scaling parameters manually using our API, UI or CLI:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
name: my_VAMP_blueprint
  clusters:
    my_cluster:
      services:
        breed:
          name: my_breed
          deployable: registry.magnetic.io/app:1.0
        scale:
          cpu: 2
          memory: 1024MB
          instances: 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also use scale-sets and references to these, which is useful when working with several teams or environments:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
name: medium_prod
cpu: 2
memory: 4096MB
instances: 3
---
name: medium_test
cpu: 0.5
memory: 1024MB
instances: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and refer to them by using:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
scale:
  reference: medium_test 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even cooler and very handy is that you can use VAMP to define automated up and down scaling. It’s very easy. In the deployment definition you simply define a Service Level Agreement (SLA) and an escalation-type. VAMP provides common built-in patterns for this, and our upcoming workflow-engine enables you to easily create your own workflows with a few lines of javascript.&lt;/p&gt;

&lt;p&gt;To setup a basic auto-scaling workflow based on the aggregated response-time of a cluster of containers we simply post the following to a VAMP cluster:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
 sla:
      # Type of SLA.
      type: response_time_sliding_window
      threshold:
        upper: 1000   # Upper threshold in milliseconds.
        lower: 100    # Lower threshold in milliseconds.
      window:
        interval: 300 # Time period in seconds used for
                      # average response time aggregation.
        cooldown: 600 # Time period in seconds. During this 
                      # period no new escalation events will 
                      # be generated. New event may be expected 
                      # not before cooldown + interval time has 
                      # been reached after the last event. 
     
      # List of escalations.
      escalations:
        - 
          type: scale_instances
          minimum: 1
          maximum: 3
          scale_by: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will constantly measure the aggregated backend response time of the running cluster of containers, and when the response-time exceeds 1000 milliseconds for over 5 minutes the number of running instances will increase with one (1) until the maximum of three instances is reached. When the response-time becomes lower than 100 milliseconds for over 10 minutes VAMP will make sure the number of instances is scaled down one by one, until the defined minimum of one instance is reached again. VAMP will make sure that new instances are correctly load-balanced, and that removed instances will be correctly drained (of course taking into account sticky sessions and TTL settings).&lt;/p&gt;

&lt;p&gt;VAMP does not only support horizontal scaling as described above, but also vertical scaling (changing memory or CPU scales) and the grouping of multiple escalations, both in sequence or in parallel.&lt;/p&gt;

&lt;h2 id=&#34;getting-started-with-vamp-and-dc-os&#34;&gt;Getting started with VAMP and DC/OS&lt;/h2&gt;

&lt;p&gt;What do I need to do if I want to start experimenting with all these possibilities that VAMP and DC/OS deliver as described in this blog post?&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;First setup a cluster and download and install DC/OS as instructed: &lt;a href=&#34;https://dcos.io/docs/1.7/administration/installing/custom/gui/&#34;&gt;https://dcos.io/docs/1.7/administration/installing/custom/gui/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now install VAMP as a DC/OS package: &lt;a href=&#34;http://vamp.io/documentation/installation/mesosphere_dcos/&#34;&gt;http://vamp.io/documentation/installation/mesosphere_dcos/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now you can start with our Getting started with VAMP tutorials: &lt;a href=&#34;http://vamp.io/documentation/guides/&#34;&gt;http://vamp.io/documentation/guides/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;tl-dr-summing-it-up&#34;&gt;TL/DR &amp;amp; Summing it up&lt;/h2&gt;

&lt;p&gt;To make the best use of containers in production environments you need a container cluster manager to deliver resilience and performance. Mesos has an amazing heritage, and all this experience is now packaged into the DC/OS. This gives you an opensource container-cluster solution that is easy to install, battle-hardened, well documented, and solves real world problems by providing an extensive and growing set of solutions and frameworks that run on top of it.&lt;/p&gt;

&lt;p&gt;One of these solutions is VAMP (www.vamp.io) an opensource framework that makes canary-testing/releasing and autoscaling of containers and microservices easy and powerful. Companies like Spotify, Facebook and Booking.com have moved from linear continuous deployment pipelines to continuous improvement feedback-loops using canary-testing&amp;amp;releasing and autoscaling patterns. Canary-testing &amp;amp; releasing is an advanced version of blue-green deployments to avoid downtime when releasing new software.&lt;/p&gt;

&lt;p&gt;When deploying new versions of their software to production they expose these to a small percentage of visitors with specific criteria (a ‘bucket’ or ‘cohort’) to test and validate technical and business performance. When successfully validated they increase the percentage of visitors that land on the new version and at the same time scale-up the number of instances and/or assigned resources to handle the increasing number of visitors with the desired performance-requirements like f.e. response time.&lt;/p&gt;

&lt;p&gt;These canary-test/release and autoscaling patterns require a complex and highly technical coordination and choreography between deploying, load-balancing, metric-aggregation and scaling. Until recently this was only possible to the few companies that could dedicated large amounts of research and development capabilities to this problem.&lt;/p&gt;

&lt;p&gt;VAMP and DC/OS now make it easy to setup and leverage a container-cluster for production-grade environments and start working with containers, microservices and canary-test/release and autoscaling patterns without having to custom-build or understand the underlying technologies.&lt;/p&gt;

&lt;p&gt;Olaf Molenveld
olaf@magnetic.io&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Vamp 0.7.10: weight editing and easy A/B-testing with environment variables</title>
      <link>http://vamp.io/2015/08/release-0710/</link>
      <pubDate>Fri, 28 Aug 2015 00:00:00 UTC</pubDate>
      
      <guid>http://vamp.io/2015/08/release-0710/</guid>
      <description>

&lt;p&gt;Vamp &lt;strong&gt;release 0.7.10&lt;/strong&gt; introduces a nice addition to the UI where you can easily shift traffic between multiple services based on percentages. You can combine this with our revised way of handling environment variables.&lt;/p&gt;

&lt;p&gt;Just launch two exactly the same containers and tweak them using standard &lt;code&gt;ENV&lt;/code&gt; variables. &lt;strong&gt;A/B-testing Docker containers&lt;/strong&gt; has never been easier.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://vamp.io/img/weight_sliders.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;easy-a-b-testing&#34;&gt;Easy A/B-testing&lt;/h2&gt;

&lt;p&gt;During our last sprint we dedicated a lot of time to how we can make simple A/B-testing scenario&amp;rsquo;s easier. Taking in the feedback we get through Github we changed how we handle the scope of environment variables.&lt;/p&gt;

&lt;p&gt;You can now just launch two (or more) of exactly the same containers and just give them different environment variables to tweak and configure the application inside the container. To this, we added a nice little extra in the UI to shift around the traffic based on percentages.&lt;/p&gt;

&lt;p&gt;An extra benefit of changing how we deal with scopes is the option to override variables on different levels if you want to. This allows for a separation of concerns, i.e. have operations override settings provided by developers. &lt;a href=&#34;http://vamp.io/documentation/using-vamp/environment_variables/#environment-variable-scope&#34;&gt;Check the updated docs for more scenario&amp;rsquo;s →&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;clearer-references&#34;&gt;Clearer references&lt;/h2&gt;

&lt;p&gt;In addition to changing how we deal with scopes we made using references to artefacts more explicit. You now use the &lt;code&gt;reference&lt;/code&gt; or &lt;code&gt;ref&lt;/code&gt; keyword to include artefacts by name in other artefacts. Previously, this was done using the &lt;code&gt;name&lt;/code&gt; keyword, which was confusing. &lt;a href=&#34;http://vamp.io/documentation/using-vamp/references/&#34;&gt;Check the reference docs for more info →&lt;/a&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Note&lt;/strong&gt;: this is a breaking change. Please update blueprints and other artefacts accordingly.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&#34;docker-dialect&#34;&gt;Docker dialect&lt;/h2&gt;

&lt;p&gt;When using Vamp with Docker, you can now add Docker API specific commands to your blueprint. This means you can hook up volumes or use a private registry, or basically do anything the Docker API allows. The example below mount &amp;ldquo;/tmp&amp;rdquo;
in every &lt;code&gt;busybox&lt;/code&gt; container:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
name: busybox
clusters:
  busyboxes:
    services:
      breed:
        name: busybox-breed
        deployable: busybox:latest
      docker:
        Volumes:
          &amp;quot;/tmp&amp;quot;: ~
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;a href=&#34;http://vamp.io/documentation/using-vamp/blueprints/#dialects&#34;&gt;Check the dialects docs for more info →&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;simple-deployment-validation-or-a-noop-run&#34;&gt;Simple deployment validation, or a NOOP run&lt;/h2&gt;

&lt;p&gt;The last thing I&amp;rsquo;d like to point out is that we&amp;rsquo;ve added the &lt;code&gt;?validate_only=true&lt;/code&gt; option to de &lt;code&gt;/deployments&lt;/code&gt; endpoint. This means you can have Vamp validate whether the blueprint you are about to deploy is actually valid!
Vamp will check if all references to other artefacts are in place and if the blueprint is semantically valid.
This works like a &amp;ldquo;noop&amp;rdquo; (no operation) run and helps with sanity checking complex blueprints. &lt;a href=&#34;http://vamp.io/documentation/api-reference/deployments/&#34;&gt;Check the deployment API docs for more info →&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Release notes:&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/magneticio/vamp/releases/tag/0.7.10&#34;&gt;https://github.com/magneticio/vamp/releases/tag/0.7.10&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Closed issues:&lt;/strong&gt;&lt;br /&gt;
&lt;a href=&#34;https://github.com/magneticio/vamp/issues?q=is%3Aissue+milestone%3A0.7.10+is%3Aclosed&#34;&gt;https://github.com/magneticio/vamp/issues?q=is%3Aissue+milestone%3A0.7.10+is%3Aclosed&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Tim Nolet, CTO&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Going native - building native packages for Vamp</title>
      <link>http://vamp.io/2015/08/going-native/</link>
      <pubDate>Wed, 05 Aug 2015 00:00:00 UTC</pubDate>
      
      <guid>http://vamp.io/2015/08/going-native/</guid>
      <description>

&lt;p&gt;To give you a better experience installing Vamp, we decided to create native installers for the most common used platforms.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://vamp.io/img/packaging.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Okay, we already did the hard part: We designed and created the software, performed the tests, made a zip file, put the zip file on the website and wrote some documentation.&lt;/p&gt;

&lt;p&gt;Only thing you had to do, is download the file, unzip it, put it contents in the correct directory, change the configuration files and write some startup scripts. And repeat these steps for every Vamp module. Easy as eating pie, right?&lt;/p&gt;

&lt;p&gt;We didn&amp;rsquo;t think so either.&lt;/p&gt;

&lt;p&gt;Time to go native.&lt;/p&gt;

&lt;h2 id=&#34;targeting-platforms&#34;&gt;Targeting platforms&lt;/h2&gt;

&lt;p&gt;The Vamp modules will be typically installed on a server, with the exception of Vamp CLI, which is likely to be installed on desktop/laptop environments also. For servers, we&amp;rsquo;ll create native installers for the &lt;a href=&#34;http://www.serverwatch.com/columns/article.php/3900711/The-Top-10-Linux-Server-Distributions.htm&#34;&gt;most widely used Linux flavors&lt;/a&gt;; for the desktop we&amp;rsquo;ll also include OSX, since thats what we are using ourself. And even for the platforms we don&amp;rsquo;t target directly, we can make things a bit easier, by creating a universal install package.&lt;/p&gt;

&lt;h2 id=&#34;sbt-native-packager&#34;&gt;SBT Native Packager&lt;/h2&gt;

&lt;p&gt;Where a Java developer uses Maven, a Scala developer uses SBT as its build system. The SBT ecosystem is quite vibrant and there a some real nice plugins available. One of them is the &lt;a href=&#34;http://www.scala-sbt.org/sbt-native-packager/&#34;&gt;SBT native packager plugin&lt;/a&gt;, which promisses to package your software to run anywhere.&lt;/p&gt;

&lt;p&gt;We created a &lt;a href=&#34;http://github.com/magneticio/vamp-dist&#34;&gt;separate project&lt;/a&gt; for the distribution aspect of Vamp, which contains a directory for each module we want to publish. Out of the box, sbt-native-packager has the ability to create a so called &amp;lsquo;Universal&amp;rsquo; package. This is a zip file in which you&amp;rsquo;ll find a bin directory and a lib directory. To use a universal package, all you have to do is unzip the file and add the bin directory to your PATH statement. That is already a huge improvement.&lt;/p&gt;

&lt;h2 id=&#34;universal-customization&#34;&gt;Universal customization&lt;/h2&gt;

&lt;p&gt;Having a closer look at the Universal package, there are somethings we&amp;rsquo;d like to change.
First of, the contents of the lib directory. It contains all the jar files our application needs, which are quite a few file. Lets change that, by wrapping the files into one single big jar file. With the help of the &lt;a href=&#34;https://github.com/sbt/sbt-assembly&#34;&gt;sbt-assembly&lt;/a&gt; plugin this can be done quite easy, as the excerpt from the CLI   &lt;a href=&#34;https://github.com/magneticio/vamp-dist/blob/master/cli/build.sbt&#34;&gt;build.sbt&lt;/a&gt; file shows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;//Make a fat jar
assemblyJarName in assembly := &amp;quot;vamp-cli.jar&amp;quot;

// removes all jar mappings in universal and appends the fat jar
mappings in Universal := {
 val universalMappings = (mappings in Universal).value
 val fatJar = (assembly in Compile).value
 // removing means filtering
 val filtered = universalMappings filter {
   case (file, fileName) =&amp;gt;  ! fileName.endsWith(&amp;quot;.jar&amp;quot;)
 }
 // add the fat jar
 filtered :+ (fatJar -&amp;gt; (&amp;quot;lib/&amp;quot; + fatJar.getName))
}

// the bash scripts classpath only needs the fat jar
scriptClasspath := Seq( (assemblyJarName in assembly).value )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second thing we want to change in the CLI package, is the contents of the bin directory. The scripts in the bin directory are automatically generated when the package is being build and there are methods of adding or overriding functionality. For Vamp CLI, we want the name of the executable script to be &lt;code&gt;vamp&lt;/code&gt; instead of &lt;code&gt;vamp-cli&lt;/code&gt; and we&amp;rsquo;d like to include scripting to verify the installed Java version. For this, we had to add some lines to the &lt;a href=&#34;https://github.com/magneticio/vamp-dist/blob/master/cli/build.sbt&#34;&gt;build.sbt&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;executableScriptName := &amp;quot;vamp&amp;quot;

// Add check for Java 8 (not for windows)
bashScriptExtraDefines ++= IO.readLines(baseDirectory.value / &amp;quot;scripts&amp;quot; / &amp;quot;java_check.sh&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;standard-linux&#34;&gt;Standard Linux&lt;/h2&gt;

&lt;p&gt;For Linux, we&amp;rsquo;d like to support Ubtuntu / Debian &amp;amp; Red Hat / CentOS. This means, we need to create .deb and .rpm packages. To do this, we specify some values in the build.sbt, to be included in the package mata information. For .deb packages, we&amp;rsquo;ve added:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;description := &amp;quot;This is the command line interface for VAMP&amp;quot;
packageDescription := &amp;quot;CLI for the Very Awesome Microservices Platform&amp;quot;
packageSummary := &amp;quot;The Vamp CLI&amp;quot;
maintainer :=  &amp;quot;Matthijs Dekker &amp;lt;matthijs@magnetic.io&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the .rpm package, we&amp;rsquo;ve added:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;rpmVendor := &amp;quot;Magnetic.io&amp;quot;
rpmUrl := Some(&amp;quot;http://vamp.io&amp;quot;)
rpmLicense := Some(&amp;quot;Apache 2&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s it. Now we can create Linux packages just by executing the sbt tasks &lt;code&gt;debian:packageBin&lt;/code&gt; and &lt;code&gt;rpm:packageBin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Well not quite &amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;the-init-problem&#34;&gt;The init problem&lt;/h2&gt;

&lt;p&gt;The .deb package for Vamp CLI was easy to setup, but for our other components, things got a little more complex. The &lt;a href=&#34;http://www.zdnet.com/article/after-linux-civil-war-ubuntu-to-adopt-systemd/&#34;&gt;Linux &amp;lsquo;civil war&amp;rsquo;&lt;/a&gt;, which was all about which system to use for startup and shutdown routines, left a fragmented Linux world. Ubuntu 14.04 LTS uses &lt;code&gt;Upstart&lt;/code&gt;, Debian 7 uses &lt;code&gt;SystemV&lt;/code&gt; and Debian 8 and Ubuntu 15.04 &lt;code&gt;Systemd&lt;/code&gt;. Since we want to support all 4 releases, this means we have to create 3 different .deb packages, one for each init system.&lt;/p&gt;

&lt;p&gt;Luckily, sbt-native-packager has support for all three init systems and by specifying the &lt;code&gt;serverLoading&lt;/code&gt; system, you can tell it which one to use.
For example, to use &lt;code&gt;SystemV&lt;/code&gt; you would use:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;serverLoading in Debian := com.typesafe.sbt.packager.archetypes.ServerLoader.SystemV
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With some SBT trickery, defining a new task &amp;lsquo;packageDebianAll&amp;rsquo;, we can create packages for all three init systems.
For full details, see the &lt;a href=&#34;https://github.com/magneticio/vamp-dist/blob/master/core/build.sbt&#34;&gt;build.sbt&lt;/a&gt; file for Vamp Core.&lt;/p&gt;

&lt;h2 id=&#34;configuration-data&#34;&gt;Configuration &amp;amp; data&lt;/h2&gt;

&lt;p&gt;Our server applications require configuration files and need to write data to disk. By adding &lt;code&gt;mappings&lt;/code&gt;, we can include files into the package.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;mappings in Universal &amp;lt;+= (packageBin in Compile, sourceDirectory ) map { (_, src) =&amp;gt;
  val conf = src / &amp;quot;main&amp;quot; / &amp;quot;resources&amp;quot; / &amp;quot;reference.conf&amp;quot;
  conf -&amp;gt; &amp;quot;conf/application.conf&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will create a &lt;code&gt;conf&lt;/code&gt; directoy in our package, with a file called &lt;code&gt;application.conf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To have the configuration file picked up by the startup script, we add it to the &lt;code&gt;bashScriptExtraDefines&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;bashScriptExtraDefines += &amp;quot;&amp;quot;&amp;quot;addJava &amp;quot;-Dconfig.file=${app_home}/../conf/application.conf&amp;quot;&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have configured our application to write data in a &lt;code&gt;data&lt;/code&gt; directory, which we need to create when installing the software:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Add an empty folder to mappings
linuxPackageMappings += packageTemplateMapping(s&amp;quot;/usr/share/${name.value}/data&amp;quot;)() withUser(name.value) withGroup(name.value)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s it for Vamp.&lt;/p&gt;

&lt;h2 id=&#34;lets-go-all-the-way&#34;&gt;Lets GO all the way&lt;/h2&gt;

&lt;p&gt;One Vamp module got left out, &lt;a href=&#34;https://github.com/magneticio/vamp-router&#34;&gt;Vamp Router&lt;/a&gt;. While the other Vamp modules are all written in Scala, Vamp Router is a &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt; application and has it&amp;rsquo;s own build process. This build process creates .zip files, based on the hardware platform it can run on. Linux .deb &amp;amp; .rpm packages are however not created by this build, and we came up with a way to use sbt-native-packager for this purpose.&lt;/p&gt;

&lt;p&gt;First, we&amp;rsquo;ll pull the vamp-router zip file from our Bintray download site in a &lt;code&gt;resourceGenerator&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val vampRouterVersion = &amp;quot;0.7.9&amp;quot;

val platform = &amp;quot;amd64&amp;quot;

resourceGenerators in Compile += Def.task {
  val location = url(s&amp;quot;https://bintray.com/artifact/download/magnetic-io/downloads/vamp-router/vamp-router_${vampRouterVersion}_linux_$platform.zip&amp;quot;)
  IO.unzipURL(location, target.value / platform).toSeq
}.taskValue

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we create mappings, to include the files we&amp;rsquo;ve extracted from the zip file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// copy vamp-router from the extracted bintray zip
linuxPackageMappings += packageMapping( (target.value / platform / &amp;quot;vamp-router&amp;quot;,  &amp;quot;/usr/share/vamp-router/vamp-router&amp;quot;) ) withPerms &amp;quot;755&amp;quot;

// Add the config files
mappings in Universal &amp;lt;+= (packageBin in Compile, target ) map { (_, target) =&amp;gt;
  val conf = target / platform / &amp;quot;configuration&amp;quot; / &amp;quot;error_pages&amp;quot;  / &amp;quot;500rate.http&amp;quot;
  conf -&amp;gt; &amp;quot;configuration/error_pages/500rate.http&amp;quot;
}

mappings in Universal &amp;lt;+= (packageBin in Compile, target ) map { (_, target) =&amp;gt;
  val conf = target / platform / &amp;quot;configuration&amp;quot; / &amp;quot;templates&amp;quot; / &amp;quot;haproxy_config.template&amp;quot;
  conf -&amp;gt; &amp;quot;configuration/templates/haproxy_config.template&amp;quot;
}

mappings in Universal &amp;lt;+= (packageBin in Compile, target ) map { (_, target) =&amp;gt;
  val conf = target / platform / &amp;quot;examples&amp;quot; / &amp;quot;example1.json&amp;quot;
  conf -&amp;gt; &amp;quot;examples/example1.json&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We add our own start up script, since the generated one would not work for us:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Add the script file to which starts vamp-router
mappings in Universal &amp;lt;+= (packageBin in Compile, sourceDirectory ) map { (_, src) =&amp;gt;
  val bin = src / &amp;quot;templates&amp;quot; / &amp;quot;bash-template&amp;quot;
  bin -&amp;gt; &amp;quot;bin/vamp-router&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we remove the generated jar file, since there isn&amp;rsquo;t actually anything in there.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// removes all jar mappings in universal
mappings in Universal := {
  val universalMappings = (mappings in Universal).value
  val filtered = universalMappings filter {
    case (file, fileName) =&amp;gt;  ! fileName.endsWith(&amp;quot;.jar&amp;quot;)
  }
  filtered
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the packages we are creating have dependencies and are not architecture independent, we need to add some additional statements to reflect this in the meta data of the packages&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val rpmArchitecture=&amp;quot;x86_64&amp;quot;
val debianArchitecture = &amp;quot;amd64&amp;quot;

debianPackageDependencies in Debian ++= Seq(&amp;quot;haproxy&amp;quot;, &amp;quot;bash (&amp;gt;= 2.05a-11)&amp;quot;)
packageArchitecture in Debian := debianArchitecture
debianSection in Debian := &amp;quot;net&amp;quot;

packageArchitecture in Rpm := rpmArchitecture
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this done, we can create packages by running &lt;code&gt;sbt rpm:packageBin&lt;/code&gt; and &lt;code&gt;sbt packageDebianAll&lt;/code&gt;. This will create the debian &lt;code&gt;amd64&lt;/code&gt; and the rpm &lt;code&gt;x86_64&lt;/code&gt; packages. For the Debian &lt;code&gt;i386&lt;/code&gt; packages, we needed to repeat the trick, which we&amp;rsquo;ve done by simple duplicating the whole &lt;a href=&#34;https://github.com/magneticio/vamp-dist/tree/master/router-amd64&#34;&gt;router-amd64&lt;/a&gt; directory.&lt;/p&gt;

&lt;p&gt;And that wraps up all Linux packaging.&lt;/p&gt;

&lt;h2 id=&#34;brewing-our-first-osx-package&#34;&gt;Brewing our first OSX package&lt;/h2&gt;

&lt;p&gt;A popular method of installing software on OSX is using &lt;a href=&#34;http://brew.sh/&#34;&gt;homebrew&lt;/a&gt;. It allows you to install software from the command line, without the hassle of the Apple App Store. Creating a &lt;code&gt;brew&lt;/code&gt; package is not that hard. We setup an additional github repository, &lt;a href=&#34;https://github.com/magneticio/homebrew-vamp&#34;&gt;homebrew-vamp&lt;/a&gt;, here we could store our &lt;code&gt;formula&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Our forumula uses the Vamp CLI Universal package as a basis. For the brew package, we add an &lt;a href=&#34;https://github.com/magneticio/vamp-dist/blob/master/cli/src/scripts/brew_vamp&#34;&gt;additional script&lt;/a&gt; to the Universal package&lt;/p&gt;

&lt;p&gt;The complete formula is just a couple of lines of Ruby&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &amp;quot;formula&amp;quot;

class Vamp &amp;lt; Formula
  homepage &amp;quot;http://vamp.io&amp;quot;
  version &amp;quot;0.7.9&amp;quot;
  url &amp;quot;https://bintray.com/artifact/download/magnetic-io/downloads/vamp-cli/vamp-cli-#{version}.zip&amp;quot;
  # generate the sha256 hash on your mac with the command: shasum -a 256 &amp;lt;filename&amp;gt;
  sha256 &amp;quot;c6385ceff1200c1f990bf133f5189270eca4a174ceedacb4a8e9915eda3b02ca&amp;quot;

  def install
      inreplace &amp;quot;brew/vamp&amp;quot;, &amp;quot;##PREFIX##&amp;quot;, &amp;quot;#{prefix}&amp;quot;
      prefix.install &amp;quot;lib/vamp-cli.jar&amp;quot;
      bin.install &amp;quot;brew/vamp&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we release a new version of Vamp, we need to update our formula, with the latest version number and an updated sha256 hash.&lt;/p&gt;

&lt;h2 id=&#34;fire-and-forget&#34;&gt;Fire and forget&lt;/h2&gt;

&lt;p&gt;With everything setup to create packages, the next step was automating it, so we can publish all packages with the push of a button. For every release, we update the version number the build.sbt files and update the library dependencies. Once, we push these changes to &lt;a href=&#34;https://github.com/magneticio/vamp-dist&#34;&gt;Github&lt;/a&gt;, Travis CI will start building the packages and with the help of some custom bash scripts, push it all to &lt;a href=&#34;https://bintray.com/magnetic-io/&#34;&gt;Bintray&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The final step is to update the brew formula on Github and we&amp;rsquo;ve done another release!&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Vamp 0.7.9: introducing the UI and CLI.</title>
      <link>http://vamp.io/2015/08/release-079/</link>
      <pubDate>Sun, 02 Aug 2015 00:00:00 UTC</pubDate>
      
      <guid>http://vamp.io/2015/08/release-079/</guid>
      <description>&lt;p&gt;We just pushed &lt;strong&gt;release 0.7.9&lt;/strong&gt; which is easily the biggest Vamp release to date! With this release we focused on making Vamp &lt;strong&gt;easy to install&lt;/strong&gt; and work with.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://vamp.io/img/screenshots/deploy_detail.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;First of all, we package the first version of our &lt;strong&gt;graphical user interface&lt;/strong&gt;. With this ReactJS based UI, you can create, update and delete Vamp artefacts quickly and dive into the Vamp metrics feed. &lt;a href=&#34;http://vamp.io/quick-start&#34;&gt;Quick start →&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Secondly, we released the first version of the &lt;strong&gt;Vamp command line interface&lt;/strong&gt;. The CLI allows admins and Devops engineers to do fully automated canary releases and blue/green deployments on Docker and Mesophere&amp;rsquo;s/DCOS Marathon from CI tools like Jenkins or just from bash scripts.&lt;/p&gt;

&lt;p&gt;You can install the CLI on your Mac using Homebrew, &lt;a href=&#34;http://vamp.io/documentation/cli-reference/&#34;&gt;Learn more →&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://asciinema.org/a/371lzojapwenuoxd7ihta3857?autoplay=1&#34; target=&#34;_blank&#34;&gt;&lt;img src=&#34;https://asciinema.org/a/371lzojapwenuoxd7ihta3857.png&#34; width=&#34;700&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Thirdly, we&amp;rsquo;ve updated our website, the configuration and installation documentation and quick start to make using and installing Vamp easier than ever. We support native package managers &lt;strong&gt;Centos, RHEL, Debian, Ubuntu&lt;/strong&gt;. &lt;a href=&#34;http://vamp.io/installation/&#34;&gt;Check the docs →&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Closed issues:&lt;br /&gt;
&lt;a href=&#34;https://github.com/magneticio/vamp/issues?q=is%3Aissue+milestone%3A0.7.9+is%3Aclosed&#34;&gt;https://github.com/magneticio/vamp/issues?q=is%3Aissue+milestone%3A0.7.9+is%3Aclosed&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Tim Nolet, CTO&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>8 Docker productivity hacks for better living</title>
      <link>http://vamp.io/2015/06/8-docker-productivity-hacks/</link>
      <pubDate>Tue, 16 Jun 2015 00:00:00 UTC</pubDate>
      
      <guid>http://vamp.io/2015/06/8-docker-productivity-hacks/</guid>
      <description>

&lt;p&gt;&lt;img src=&#34;http://vamp.io/img/docker_nyan.svg&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve been building smaller and bigger tools on/for/with Docker for roughly the last 1,5 years.
During that time I&amp;rsquo;ve found I always come back to using little productivity hacks and one-liners that
I found on the internet or came up with myself. Here they are in one place, as much as for our own reference
as for anybody else to enjoy.  We use this stuff every day. Here we go:&lt;/p&gt;

&lt;h2 id=&#34;1-remove-images-that-are-no-longer-used-by-a-container&#34;&gt;1. Remove images that are no longer used by a container&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s free up some disk space!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker rmi `docker images -q -f dangling=true`
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2-remove-all-exited-containers&#34;&gt;2. Remove all exited containers&lt;/h2&gt;

&lt;p&gt;Let&amp;rsquo;s free up some more disk space!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker rm `docker ps -q -a -f status=exited`
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;3-log-into-an-already-running-container&#34;&gt;3. Log into an already running container&lt;/h2&gt;

&lt;p&gt;Somehow it took me ages to figure this one out. Hope I&amp;rsquo;m not the only dummy. Of course, the container should have some
shell installed, like bash.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker exec -i -t &amp;lt;ID_OF_RUNNING_CONTAINER&amp;gt; /bin/bash
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;4-run-top-inside-a-container&#34;&gt;4. Run &amp;ldquo;top&amp;rdquo; inside a container&lt;/h2&gt;

&lt;p&gt;This one is somewhat controversial. Resource usage in Docker is &lt;a href=&#34;https://goldmann.pl/blog/2014/09/11/resource-management-in-docker/&#34;&gt;counterintuitive&lt;/a&gt; and &lt;a href=&#34;https://docs.docker.com/articles/runmetrics/&#34;&gt;complicated&lt;/a&gt;. Having said that, just running top
inside a container gives me a relatively good insight how things are doing in that container`s context:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ docker exec -t &amp;lt;ID_OF_RUNNNIG_CONTAINER&amp;gt; /bin/sh -c &amp;quot;export TERM=xterm-256color &amp;amp;&amp;amp; top -bn 2&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;P.S: Ignore the first output cycle. Why? Because &lt;a href=&#34;http://unix.stackexchange.com/questions/58539/top-and-ps-not-showing-the-same-cpu-result&#34;&gt;reasons&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&#34;5-don-t-expect-anything-magic-from-the-latest-tag&#34;&gt;5. Don&amp;rsquo;t expect anything magic from the &amp;ldquo;:latest&amp;rdquo; tag&lt;/h2&gt;

&lt;p&gt;One of the huge misconceptions among fresh Docker users. The &lt;code&gt;:latest&lt;/code&gt; tag has no special magic. It is not the &lt;code&gt;HEAD&lt;/code&gt;
in a Git log. It is not an automatic pointer to the top of of your stack of images. It is just a convention. Getting
the &lt;code&gt;:latest&lt;/code&gt; version of an image implies you trust the creator of the image to really tag the last one the build with the
&lt;code&gt;:latest&lt;/code&gt; tag. More info see this post by &lt;a href=&#34;http://container-solutions.com/2015/01/docker-latest-confusion/&#34;&gt;our friends at Container Solutions&lt;/a&gt;&lt;/p&gt;

&lt;h2 id=&#34;6-cut-container-download-time-with-export-load-in-vagrant&#34;&gt;6. Cut container download time with export/load in Vagrant&lt;/h2&gt;

&lt;p&gt;Not a real one-liner, but hey! When building stuff with (CoreOS) Vagrant boxes, I destroy those boxes quite often just to get a clean slate. However, my box runs Docker and stores the images inside the box. The box now has to download some of the containers I run in that box every time I refresh my environment. Let&amp;rsquo;s fix that.&lt;/p&gt;

&lt;p&gt;Just save the Docker image to disk as a tar file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-bash&#34;&gt;docker save magneticio/myimage:1.0 &amp;gt; /home/share/magneticio_myimage_10.tar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now mount your disk to Vagrant and import it using this snippet in your Vagrantfile:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;# Vagrantfile
MY_CONTAINER=&amp;quot;magneticio_myimage_10.tar&amp;quot;
vm.synced_folder &amp;quot;.&amp;quot;, &amp;quot;/home/share&amp;quot;, id: &amp;quot;core&amp;quot;, :nfs =&amp;gt; true, :mount_options =&amp;gt; [&#39;nolock,vers=3,udp&#39;]
config.vm.provision :shell, :inline =&amp;gt; &amp;quot;export TMPDISK=/&amp;quot;, :privileged =&amp;gt; false
if File.exist?(MY_CONTAINER)
    config.vm.provision :shell, :inline =&amp;gt; &amp;quot;docker load -i /home/share/#{MY_CONTAINER}&amp;quot;, :privileged =&amp;gt; false
end
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;7-use-boot2docker-shellinit-to-setup-your-docker-env-variables&#34;&gt;7. Use &amp;ldquo;boot2docker shellinit&amp;rdquo; to setup your Docker ENV variables&lt;/h2&gt;

&lt;p&gt;Destroying and restarting a lot of &lt;a href=&#34;http://boot2docker.io/&#34;&gt;boot2docker&lt;/a&gt; instances on OSX? Creating too many terminal sessions? Use this your Docker client setup correctly for boot2docker.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ eval $(boot2docker shellinit)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;8-read-the-dockerfile-best-practices-info&#34;&gt;8. Read the &amp;ldquo;Dockerfile best practices&amp;rdquo; info&lt;/h2&gt;

&lt;p&gt;Really useful and compulsory reading: &lt;a href=&#34;https://docs.docker.com/articles/dockerfile_best-practices/&#34;&gt;https://docs.docker.com/articles/dockerfile_best-practices/&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Vamp 0.7.6: introducing the Marathon dialect</title>
      <link>http://vamp.io/2015/05/release-076/</link>
      <pubDate>Thu, 21 May 2015 00:00:00 UTC</pubDate>
      
      <guid>http://vamp.io/2015/05/release-076/</guid>
      <description>

&lt;p&gt;Release 0.7.6 is tagged and you can check the &lt;a href=&#34;https://github.com/magneticio/vamp/releases/tag/0.7.6&#34;&gt;full release note on Github&lt;/a&gt;. Notice that there are breaking changes in this release so please update where necessary. We&amp;rsquo;ve updated our &lt;a href=&#34;http://vamp.io/getting-started/&#34;&gt;getting started tutorial&lt;/a&gt; to reflect the latest changes.
Some of the highlights are below.&lt;/p&gt;

&lt;h2 id=&#34;mesosphere-marathon-dialect&#34;&gt;Mesosphere Marathon dialect&lt;/h2&gt;

&lt;p&gt;Vamp now allows you to use Marathon specific tags inside Vamp blueprints by using the &lt;code&gt;marathon:&lt;/code&gt; tag. We call this a &amp;ldquo;dialect&amp;rdquo;. We will be enabling these dialects for all platforms Vamp supports (i.e. a &amp;lsquo;straight&amp;rsquo; Docker driver and Kubernetes are on the roadmap).&lt;/p&gt;

&lt;p&gt;This effectively allows you to make full use of the underlying Marathon features like mounting disks, settings commands and providing access to private Docker registries.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s look at an example blueprint that pulls an image from private repo, mounts some volumes, sets some labels and gets run with an ad hoc command: all taken care of by Marathon.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;name: busy-top:1.0

clusters:

  busyboxes:
    services:
      breed:
        name: busybox
        deployable: registry.magnetic.io/busybox:latest
      marathon:
       cmd: &amp;quot;top&amp;quot;      
       uris:
         -
           &amp;quot;https://some_host/some_path/some_file_with_docker_credentials&amp;quot;
       labels:
         environment: &amp;quot;staging&amp;quot;
         owner: &amp;quot;buffy the vamp slayer&amp;quot;
       container:  
         volumes:
           -
             containerPath: &amp;quot;/tmp/&amp;quot;
             hostPath: &amp;quot;/tmp/&amp;quot;
             mode: &amp;quot;RW&amp;quot;
      scale:
        cpu: 0.1       
        memory: 256  
        instances: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the following:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Under the &lt;code&gt;marathon:&lt;/code&gt; tag, we provide the command to run in the container by setting the &lt;code&gt;cmd:&lt;/code&gt; tag.&lt;/li&gt;
&lt;li&gt;We provide a url to some credentials file in the &lt;code&gt;uri&lt;/code&gt; array. As described &lt;a href=&#34;https://mesosphere.github.io/marathon/docs/native-docker.html#using-a-private-docker-repository&#34;&gt;in the Marathon docs&lt;/a&gt; this enables Mesos
to pull from a private registry, in this case registry.magnetic.io where these credentials are set up.&lt;/li&gt;
&lt;li&gt;We set some labels with some arbitrary metadata.&lt;/li&gt;
&lt;li&gt;We mount the &lt;code&gt;/tmp&lt;/code&gt; to in Read/Write mode.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We can provide the &lt;code&gt;marathon:&lt;/code&gt; tag either on the service level, or the cluster level. Any &lt;code&gt;marathon:&lt;/code&gt; tag set on the service level will override the cluster level as it is more specific. However, in 9 out of 10 cases the cluster level makes the most sense. Later, you can also mix dialects so you can prep your blueprint for multiple environments and run times within one description.&lt;/p&gt;

&lt;p&gt;We are convinced this is a very convenient addition and helps users to leverage their container platform while using Vamp&amp;rsquo;s powerful, higher level features.&lt;/p&gt;

&lt;p&gt;Find all downloadable packages at:&lt;br /&gt;
&lt;a href=&#34;https://bintray.com/magnetic-io/downloads&#34;&gt;https://bintray.com/magnetic-io/downloads&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Closed issues:&lt;br /&gt;
&lt;a href=&#34;https://github.com/magneticio/vamp/issues?q=is%3Aissue+milestone%3A0.7.6+is%3Aclosed&#34;&gt;https://github.com/magneticio/vamp/issues?q=is%3Aissue+milestone%3A0.7.6+is%3Aclosed&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Tim Nolet, CTO&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Updates to docs and tutorial resources</title>
      <link>http://vamp.io/2015/05/updates-docs/</link>
      <pubDate>Thu, 07 May 2015 00:00:00 UTC</pubDate>
      
      <guid>http://vamp.io/2015/05/updates-docs/</guid>
      <description>&lt;p&gt;Hi,&lt;br /&gt;
Just a short update from HQ. Over the last two weeks we spend some time updating, refreshing and sharpening our documentation
and some of the resources that go with the docs and tutorials. Here&amp;rsquo;s a list!&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Updated our &lt;a href=&#34;https://github.com/magneticio/vamp-docker&#34;&gt;vamp-docker repo&lt;/a&gt; with fresh Dockerfiles
for spinning up a Mesosphere cluster and a private Docker registry. All images are also pushed to our &lt;a href=&#34;https://registry.hub.docker.com/repos/magneticio/&#34;&gt;Docker hub&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Added and updated documentation on routing &amp;amp; filters, SLA&amp;rsquo;s and the underlying event system. Check it out &lt;a href=&#34;http://vamp.io/documentation/using-vamp/routings-and-filters/&#34;&gt;here&lt;/a&gt; and &lt;a href=&#34;http://vamp.io/documentation/using-vamp/sla-and-escalations/&#34;&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Added a section on the REST API for Vamp Core and Vamp Router.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We are slowly but surely moving to Beta! Yay!&lt;/p&gt;

&lt;p&gt;Tim Nolet, CTO&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Vamp 0.7.5: Archiving and redesigned environment variable DSL</title>
      <link>http://vamp.io/2015/04/release-075/</link>
      <pubDate>Tue, 28 Apr 2015 00:00:00 UTC</pubDate>
      
      <guid>http://vamp.io/2015/04/release-075/</guid>
      <description>

&lt;p&gt;We just tagged release 0.7.5 and I&amp;rsquo;m excited about what we achieved this sprint and managed to cram into Vamp 0.7.5. Some of the highlights are below, but you can check the &lt;a href=&#34;https://github.com/magneticio/vamp/releases/tag/0.7.5&#34;&gt;full release note on Github&lt;/a&gt;. There are some breaking changes in this release,
so please update where necessary. We&amp;rsquo;ve updated our &lt;a href=&#34;http://vamp.io/getting-started/&#34;&gt;getting started tutorial&lt;/a&gt; to reflect the latest changes.&lt;/p&gt;

&lt;h2 id=&#34;archiving-of-everything&#34;&gt;Archiving of everything&lt;/h2&gt;

&lt;p&gt;From 0.7.5 on, all CRUD actions on Vamp artifacts are fully archived to Vamp Pulse. Put in simple terms: You can track all edits, updates and deletes to your microservices architecture similar to a Git log. By tracking all actions performed on any part of your container driven architecture, we give you the ability to start using that data to track changes, solve problems and spot trends.&lt;/p&gt;

&lt;p&gt;In the screencast below you can see us create, update and delete a breed on Vamp core. After that we get the archive of all those actions from Vamp pulse, together with the orginal YAML version of the breed:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://vamp.io/img/screenshots/archiving.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;environment-variables-dsl-in-blueprints-and-breeds&#34;&gt;Environment variables DSL in blueprints and breeds&lt;/h2&gt;

&lt;p&gt;In this release we focussed on redesigning our initial way of handling environment variables. Some
of our concerns were:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;how are variables used and declared in blueprints in breeds?&lt;/li&gt;
&lt;li&gt;how simple can we make it, without making it too simple?&lt;/li&gt;
&lt;li&gt;how can we allow inline variable interpolation?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;From 0.7.5 onwards, we allow straightforward naming of variables and constants. We looked at different
use cases, like:&lt;/p&gt;

&lt;h3 id=&#34;hard-set-a-variable&#34;&gt;&amp;lsquo;Hard&amp;rsquo; set a variable&lt;/h3&gt;

&lt;p&gt;You want to &amp;ldquo;hard set&amp;rdquo; an environment variable, just like doing an &lt;code&gt;export MY_VAR=some_value&lt;/code&gt; in a shell. This  variable could be some external dependency you have no direct control over: the endpoint of some service you use that is out of your control.&lt;/p&gt;

&lt;p&gt;You may also want to define a placeholder for a variable of which you do not know the actual value yet, but should be filled in when this breed is used in a blueprint: the following deployment will not run without it and you want Vamp to check that dependency. This placeholder is designated with a &lt;code&gt;~&lt;/code&gt; character.&lt;/p&gt;

&lt;pre class=&#34;prettyprint lang-yaml&#34;&gt;
name: my_breed
deployable: repo/container:version

environment_variables:
    MY_ENV_VAR1: some_string_value  # hard set
    MY_ENV_VAR1: ~                  # placeholder
&lt;/pre&gt;

&lt;h3 id=&#34;resolve-a-reference-at-deploy-time&#34;&gt;Resolve a reference at deploy time&lt;/h3&gt;

&lt;p&gt;You might want to resolve a reference and set it as the value for an environment variable. This reference can either be dynamically resolved at deploy-time, like ports and hosts names we don&amp;rsquo;t know till a deployment is done, or be a reference to a hardcoded and published constant from some other part of the blueprint or breed, typically a dependency.&lt;/p&gt;

&lt;p&gt;You would use this to hook up services at runtime based on host/port combinations or to use a hard dependency that never changes but should be provided by another breed.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Notice&lt;/strong&gt;: you use the &lt;code&gt;$&lt;/code&gt; sign to reference other statements in a blueprint and you use the &lt;code&gt;constants&lt;/code&gt; keyword
to create a list of constant values.&lt;/p&gt;

&lt;p&gt;Have a look at this example blueprint. We are describing a frontend service that has a dependency on a backend service. We pick up the actual address of the backend service using references to variables in the blueprint that are filled in at runtime. However, we also want to pick up a value that is set by &amp;ldquo;us humans&amp;rdquo;: the api path, in this case &amp;ldquo;/v2/api/customers&amp;rdquo;.&lt;/p&gt;

&lt;pre class=&#34;prettyprint lang-yaml&#34;&gt;
name: my_blueprint
clusters:

  frontend:
    breed:
      name: frontend_service
    environment_variables:
        # resolves to a host and port at runtime
        BACKEND_URL: http://$backend.host:$backend.ports.port
        # resolves to the &#34;published&#34; constant value
        BACKEND_URI_PATH: $backend.constants.uri_path        
      dependencies:
        backend: my_other_breed
  backend:
    breed:
      name: my_other_breed
    constants:
      uri_path: /v2/api/customers   
&lt;/pre&gt;

&lt;p&gt;Find all downloadable packages at:&lt;br /&gt;
&lt;a href=&#34;https://bintray.com/magnetic-io/downloads&#34;&gt;https://bintray.com/magnetic-io/downloads&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Closed issues:&lt;br /&gt;
&lt;a href=&#34;https://github.com/magneticio/vamp/issues?q=is%3Aissue+milestone%3A0.7.5+is%3Aclosed&#34;&gt;https://github.com/magneticio/vamp/issues?q=is%3Aissue+milestone%3A0.7.5+is%3Aclosed&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Tim Nolet, CTO&lt;/p&gt;
</description>
    </item>
    
    
  </channel>
</rss>