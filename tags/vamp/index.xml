<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
      <title>Vamp :: The Very Awesome Microservices Platform</title>
      <generator uri="https://hugo.spf13.com">Hugo</generator>
    <link>http://vamp.io/tags/vamp/</link>
    <language>en-us</language>
    
    <updated> May 23, 2016</updated>
    
    
    <item>
      <title>Magnetic.io VAMP raises €500K in round led by Volta Ventures to deliver opensource canary testing and releasing solution for container and microservice systems</title>
      <link>http://vamp.io/2016/05/magnetic_io-vamp-raises-500k-in-investmentround-led-by-voltaventures/</link>
      <pubDate>Mon, 23 May 2016 00:00:00 UTC</pubDate>
      
      <guid>http://vamp.io/2016/05/magnetic_io-vamp-raises-500k-in-investmentround-led-by-voltaventures/</guid>
      <description>&lt;p&gt;&lt;strong&gt;DevOps and business teams use VAMP to reduce downtime, improve time-to-market and increase performance of online software.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AMSTERDAM, May 23, 2016&lt;/strong&gt; — Magnetic.io, an Amsterdam-based hi-tech startup that develops opensource solution VAMP (&lt;a href=&#34;http://vamp.io&#34;&gt;http://vamp.io&lt;/a&gt;), today announced that it has raised € 500,000 in a round led by Volta Ventures.
VAMP adds powerful canary testing and releasing, and autoscaling features to (Docker) container and microservice based systems. These features enable DevOps teams to deliver higher quality software in a shorter time. The investment will fuel the development of VAMP’s enterprise-grade features, grow the opensource community and partner network, and boost international expansion. Existing investor Startupbootcamp (SBC) and successful entrepreneur Henri de Jong (Mijndomein) will also participate in the round. Mr. Maene, Volta Ventures’ managing partner, will join the board of directors. &lt;/p&gt;

&lt;p&gt;To solve scaling, performance and time-to-market challenges, digital-savvy organisations are quickly adopting strategies like continuous-delivery, containers and microservices. To unlock the full potential of these technologies to both IT and business, VAMP adds an &amp;ldquo;experiment system&amp;rdquo; with canary and autoscaling features that make it safe, fast and easy to release, test and scale new software versions in production. &lt;/p&gt;

&lt;p&gt;Successful online companies like Netflix, AirBnB and Facebook have already demonstrated the power of canary testing and releasing. New versions of software are continually released in production to small percentages of visitors, performance is measured and improved, and the number of allowed visitors is gradually increased to achieve a risk-free and stable full release.&lt;/p&gt;

&lt;p&gt;Until recently, it was complex and expensive to apply these canary test and release methods. With VAMP it becomes straightforward and cost effective to add these features to both new or existing architectures. VAMP can work standalone or integrate with container systems like Docker, Mesosphere DC/OS, Azure Container Service, Rancher and Kubernetes.&lt;/p&gt;

&lt;p&gt;Frank Maene, managing partner Volta Ventures: &lt;em&gt;“We like the vision Olaf and his team have on the value add of VAMP in the burgeoning containers and microservices market. We believe VAMP will play an important role in enabling smarter ways of testing, delivering and scaling online software and containers, and we are excited to become a partner of the VAMP team and help to make this happen.”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Olaf Molenveld, Magnetic.io CEO and co-founder: &lt;em&gt;“We are very excited to have Volta Ventures, Henri de Jong and SBC on board in our mission to help organisations test, deliver and scale software in a smarter and more effective way. The experience and track-record available in this extended team is huge. It will help us to accelerate the product, the company and the opensource community adoption and we are very much looking forward to work together!”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;To start working with VAMP’s Canary and autoscaling features, download the free opensource version of VAMP from &lt;a href=&#34;http://vamp.io&#34;&gt;http://vamp.io&lt;/a&gt;. An easy-to-install QuickStart package is available to start working with VAMP within 5 minutes. For information about enterprise features please email info@magnetic.io&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;About Magnetic.io&lt;/strong&gt;&lt;br /&gt;
Magnetic.io’s VAMP is an open source platform that provides features for (A/B) testing, deploying and autoscaling (micro)service oriented architectures that rely on container technology.
The company is headquartered in Amsterdam and was created by Olaf Molenveld.
www.vamp.io&lt;/p&gt;

&lt;p&gt;Contact: Olaf Molenveld, CEO,&lt;br /&gt;
olaf@magnetic.io, tel +31 653 36 27 83&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;About Volta Ventures&lt;/strong&gt;&lt;br /&gt;
Volta Ventures Arkiv invests in young and ambitious internet and software companies in the Benelux. The fund has € 55 million under management and is supported by EIF and ARKimedes-Fund II.
www.volta.ventures&lt;/p&gt;

&lt;p&gt;Contact: Frank Maene, managing partner,&lt;br /&gt;
frank@voltaventures.eu, tel. +32 477 20 17 82&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;About Startupbootcamp&lt;/strong&gt;&lt;br /&gt;
Startupbootcamp started in 2010 and has grown into an international accelerator program for startups with 13 programs in Amsterdam, Barcelona, Berlin, Eindhoven, Istanbul, London, Miami, New York and Singapore. The mentor and alumni network is spread across more than 50 countries. More information can be found at: www.startupbootcamp.org&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Persbericht  - Magnetic.io VAMP haalt €500k op in investeringsronde geleid door Volta Ventures</title>
      <link>http://vamp.io/2016/05/magnetic_io-vamp-haalt-500k-op-in-investeringsronde-geleid-door-voltaventures/</link>
      <pubDate>Mon, 23 May 2016 00:00:00 UTC</pubDate>
      
      <guid>http://vamp.io/2016/05/magnetic_io-vamp-haalt-500k-op-in-investeringsronde-geleid-door-voltaventures/</guid>
      <description>

&lt;h3 id=&#34;magnetic-io-vamp-haalt-500k-op-in-investeringsronde-geleid-door-volta-ventures-om-opensource-canary-test-en-release-platform-voor-containers-en-microservices-op-te-schalen&#34;&gt;Magnetic.io VAMP haalt €500k op in investeringsronde geleid door Volta Ventures om opensource canary test en release platform voor containers en microservices op te schalen&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;DEVOPS EN BUSINESS TEAMS GEBRUIKEN VAMP OM STORINGEN TE VOORKOMEN, RELEASES TE VERSNELLEN, EN PERFORMANCE VAN ONLINE SOFTWARE TE OPTIMALISEREN.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;AMSTERDAM, 23 Mei, 2016&lt;/strong&gt; — Magnetic.io, een in Amsterdam gevestigde hightech startup, heeft aangekondigd dat het een investering van €500.000 heeft opgehaald in een ronde geleid door Volta Ventures. Magnetic.io ontwikkelt VAMP, een opensource oplossing om canary-test en -release, en auto-scaling functionaliteiten, toe te voegen aan systemen die gebruik maken van populaire (Docker) container en microservice technologieën. De functionaliteiten die VAMP toevoegt maken het voor DevOps teams makkelijker om in minder tijd een hogere kwaliteit van online software in productie te brengen. De investering zal worden gebruikt voor de ontwikkeling van enterprise functionaliteiten voor het VAMP framework, het stimuleren en ondersteunen van de opensource community en het partner netwerk, en om de internationale groei te versnellen. Huidige investeerder Startupbootcamp (SBC) en succesvolle ondernemer Henri de Jong (Mijndomein) nemen ook deel in de investeringsronde. Dhr. Maene, managing partner van Volta Ventures, zal toetreden tot de raad van bestuur.&lt;/p&gt;

&lt;p&gt;Om uitdagingen op het gebied van online en digitale groei, performance en time-to-market op te lossen, passen steeds meer online organisaties technieken als continuous-delivery, containers en microservices toe. Om het volledige potentieel van deze technologieën te benutten, voor zowel IT als business, is een overkoepelend experimenteer-systeem zoals VAMP essentieel. Door alle onderliggende onderdelen slim te coördineren wordt het mogelijk om snel, eenvoudig en vooral risico-vrij continue nieuwe versies van online software naar productie uit te rollen, te testen, optimaliseren en op te schalen.&lt;/p&gt;

&lt;p&gt;Succesvolle online bedrijven zoals Netflix, AirBnB en Facebook passen deze “canary test en release” methode al jaren zeer succesvol toe. Zij lanceren vrijwel continue nieuwe versies en varianten van hun software naar kleine percentages bezoekers, meten en optimaliseren vervolgens de performance, en verhogen dan stapsgewijs het percentage bezoekers om zo op een risicovrije en gecontroleerde manier tot een stabiele en geoptimaliseerde upgrade te komen.&lt;/p&gt;

&lt;p&gt;Tot voor kort was het voor de meeste organisaties complex en duur om dit soort “canary methodieken” toe te passen. VAMP maakt het eenvoudig en kosteneffectief om deze slimme en veilige manier van online software in productie testen en upgraden toe te voegen aan bestaande en nieuwe architecturen. VAMP kan zowel stand-alone werken, als ook in combinatie met veelgebruikte container en microservices oplossingen zoals bijvoorbeeld Docker, Mesosphere DC/OS, Azure Container Service, Rancher en Kubernetes.&lt;/p&gt;

&lt;p&gt;Frank Maene, managing partner Volta Ventures:
&lt;em&gt;“Wij zijn overtuigd van de visie van Olaf en zijn team op de toegevoegde waarde van VAMP in een sterk groeiende container en microservices markt. Wij geloven dat VAMP een belangrijke rol zal spelen bij het mogelijk maken van het slimmer uitrollen, optimaliseren en schalen van online software en containers. Wij zijn enthousiast om hier deel van uit te maken en het VAMP team hierbij te ondersteunen.”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Olaf Molenveld, Magnetic.io CEO en co-founder:
&lt;em&gt;“We zijn zeer blij om Volta Ventures, Henri de Jong en SBC aan boord te hebben. Samen kunnen we onze missie om organisaties slimmer software te laten uitrollen, optimaliseren en schalen nog beter vorm geven. De ervaring waar we nu uit kunnen putten is zeer waardevol. Dit gaat ons absoluut helpen om ons product, het team en de opensource community verder te laten groeien.”&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Om binnen 5 minuten met VAMP’s canary en auto-scaling functionaliteiten aan de slag te gaan is een eenvoudig te installeren QuickStart versie gratis te downloaden vanaf &lt;a href=&#34;http://vamp.io&#34;&gt;http://vamp.io&lt;/a&gt;. Voor informatie over de enterprise functionaliteiten en andere vragen stuur een email naar info@magnetic.io&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Over Magnetic.io&lt;/strong&gt;&lt;br /&gt;
Magnetic.io VAMP is het opensource platform dat slimme functionaliteiten voor (A/B) testen, uitrollen en automatisch schalen toevoegt aan (micro)service en container gebaseerde architecturen. Het bedrijf is gevestigd in Amsterdam en is mede opgericht door Olaf Molenveld
www.vamp.io&lt;/p&gt;

&lt;p&gt;Contact: Olaf Molenveld, CEO,&lt;br /&gt;
olaf@magnetic.io, tel +31 653 36 27 83&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Over Volta Ventures&lt;/strong&gt;&lt;br /&gt;
Volta Ventures Arkiv investeert in jonge en ambitieuze internetbedrijven in de Benelux. Het fonds heeft € 55 miljoen onder beheer en wordt ondersteund door het EIF en ARKimedes-Fonds II.
www.volta.ventures&lt;/p&gt;

&lt;p&gt;Contact: Frank Maene, managing partner,&lt;br /&gt;
frank@voltaventures.eu, tel. +32 477 20 17 82&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Over Startupbootcamp&lt;/strong&gt;&lt;br /&gt;
Startupbootcamp is opgericht in 2010 en is inmiddels uitgegroeid tot een internationaal accelerator programma voor startups met 13 programma&amp;rsquo;s in Amsterdam, Barcelona, ​​Berlijn, Eindhoven, Istanbul, Londen, Miami, New York en Singapore. Het mentor en alumni-netwerk is verspreid over meer dan 50 landen. Meer informatie is te vinden op: www.startupbootcamp.org&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Canaries and Containers - DC/OS and VAMP</title>
      <link>http://vamp.io/2016/04/canaries-and-containers/</link>
      <pubDate>Mon, 18 Apr 2016 00:00:00 UTC</pubDate>
      
      <guid>http://vamp.io/2016/04/canaries-and-containers/</guid>
      <description>

&lt;h2 id=&#34;what-do-canaries-and-containers-have-in-common&#34;&gt;&lt;strong&gt;&lt;em&gt;What do canaries and containers have in common?&lt;/em&gt;&lt;/strong&gt;&lt;/h2&gt;

&lt;p&gt;With the advent of container-technology (developed by Google in their now famous Borg project and made wildly popular by companies like Docker and Mesosphere) innovative ways of deploying, running and (auto)scaling software like microservices become possible for everybody. But “with great power also comes great responsibility” and thus these new possibilities also need a new breed of tools to really leverage the benefits of container technology in real world production environments and scenarios.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://vamp.io/img/weight_sliders.gif&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://dcos.io&#34;&gt;DC/OS&lt;/a&gt; and &lt;a href=&#34;http://vamp.io&#34;&gt;VAMP&lt;/a&gt; are such tools that help you make it easy to get the best out of using containers when you move away from “hello world” test-setups and into real world environments.&lt;/p&gt;

&lt;p&gt;To run containers in production environments, you will need a cluster manager. A single machine to run your containers on simply doesn’t give you the resilience you are aiming for. If a machine breaks down you want your containers to instantly, automatically and transparently be moved to other machines without your users experiencing any downtime. If you need more processing-power because of increased demand you want to be able to easily and quickly add machines to increase the pool of computing-resources that your containers can transparently make use of. This is where a container cluster-manager comes in.&lt;/p&gt;

&lt;p&gt;One of the most used and battle-hardened container cluster-managers out there is Mesos. Mesos is an Apache project that spun out of technology developed and used by AirBnB and Twitter. Mesosphere is the company that is one of the core contributors to Mesos and also packages Mesos into DC/OS (the Datacenter Operation System). DC/OS is a robust and commercially supported product that is built on top of Mesos and adds powerful features like command-line and web-interfaces, simple packaging and installation, and a growing ecosystem of frameworks that can run on top of it. Mesos and DC/OS are powering famous platforms like Apple Siri, Bloomberg, Paypal, but can also be very useful on (much) smaller clusters.&lt;/p&gt;

&lt;p&gt;An important feature of DC/OS is that it’s open-source. Opensource software these days is an important aspect of running trusted and hardened production systems and has become an important requirement for engineers and IT departments alike. We believe DC/OS is a great step forward in easing the transition to and adoption of containers and container-cluster managers in real world production environments.&lt;/p&gt;

&lt;p&gt;Because of the heritage of Mesos, DC/OS delivers a very compelling way to run containers in production. It’s opensource, easy to install, well documented, fully featured and solves real world problems with a growing ecosystem of integrated solutions and frameworks that are easy to install and experiment with.&lt;/p&gt;

&lt;h2 id=&#34;canary-testing-releasing-containers&#34;&gt;Canary testing &amp;amp; releasing containers&lt;/h2&gt;

&lt;p&gt;One of the most popular and essential frameworks for Mesos and DC/OS is Marathon. Marathon is a container-orchestration framework and is designed to manage long-running jobs. Long-running jobs in containers are typically web-oriented API’s, applications and microservices.&lt;/p&gt;

&lt;p&gt;While DC/OS and Marathon make it easy to deploy, run and orchestrate these containers, you need an additional “experiment framework” to enable a process of continuously measuring, improving and scaling your container-packaged software without negatively affecting your visitors or having downtime. We call this “Continuous Improvement” and this is where VAMP comes in.&lt;/p&gt;

&lt;p&gt;Companies like Facebook, Spotify and Netflix are very successfully using a pattern called Canary testing &amp;amp; releasing. It’s an advanced variant of blue-green releasing, where you seamlessly switch from the current to a new version of software without perceived downtime for your visitors. VAMP is an opensource framework that integrates with DC/OS and Marathon and delivers canary-testing &amp;amp; releasing and autoscaling features in an easy-to-use and powerful way.&lt;/p&gt;

&lt;p&gt;When deploying one or more new versions of your software in containers to production, VAMP enables you to expose these versions to only a small percentage of your visitors with specific criteria (a ‘bucket’ or ‘cohort’).&lt;/p&gt;

&lt;p&gt;You can now test and validate the technical and/or business performance of your new software versions in this limited setting but in production. This means you don’t need to over-optimise prematurely, and can detect and fix potential  issues before you move gradually to a full scale deployment.&lt;/p&gt;

&lt;p&gt;A typical real world use-case for canary-testing &amp;amp; releasing with VAMP and DC/OS is:&lt;/p&gt;

&lt;p&gt;Validating the performance of a new (e.g. responsive) website front-end by developing and optimising it only for Chrome-browsers first, exposing it to 5% of your visitors with Chrome-browsers (you could even do this for specific resolutions and devices), validating your hypothesis (e.g. better conversion and/or faster response times), fixing technical issues, and then scaling up to a higher percentage of visitors and/or gradually adding new browser-types until you reach a full deployment.&lt;/p&gt;

&lt;p&gt;With VAMP on DC/OS this can done by simply sending these rules to VAMP (either using our Graphical UI, command-line interface or directly to the REST API):&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
 frontend_A: 
   weight: 100%
 frontend_B:
   weight: 0%
   filter_strength: 5%
   filters:
     - user-agent == Chrome
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Other use-cases are the validation and testing of different technological and architectural solutions (f.e. couchDB vs MongoDB as an embedded microservice datastore) in production and without impacting your visitors, or experimental finding of the optimal balance between allocated computing-resources (i.e. running costs) and the performance of your services.&lt;/p&gt;

&lt;p&gt;VAMP supports grouping of filters, Boolean expressions (AND/OR/NOT), and provides a built-in set of commonly used “routing short codes” like cookies, browser-types, headers and host-names in addition to supporting HAProxy ACL rules and configuration templates. VAMP also supports sticky sessions, URL path rewriting (very useful for API versioning, aggregation and routing) and makes sure that services are correctly “drained” when taken out of the routing.&lt;/p&gt;

&lt;h2 id=&#34;autoscaling&#34;&gt;Autoscaling&lt;/h2&gt;

&lt;p&gt;So now we know that VAMP makes it very easy to implement all kinds of useful canary-testing &amp;amp; releasing patterns. But when you are increasing the percentage of visitors or are expanding your filter-criteria to allow more visitors, you also need to scale up the number of running instances or allocated computing resources. Of course with Marathon it’s easy to use the UI or API to set the scale of the running containers. But wouldn’t it be much more practical if you could simply change the scaling-settings at the same time when changing the routing and load-balancing rules? Or even cooler: change the scaling automatically, based on performance-criteria? We thought so too, so we made it easy to do with VAMP:&lt;/p&gt;

&lt;p&gt;In VAMP you can set scaling parameters manually using our API, UI or CLI:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
name: my_VAMP_blueprint
  clusters:
    my_cluster:
      services:
        breed:
          name: my_breed
          deployable: registry.magnetic.io/app:1.0
        scale:
          cpu: 2
          memory: 1024MB
          instances: 4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also use scale-sets and references to these, which is useful when working with several teams or environments:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
name: medium_prod
cpu: 2
memory: 4096MB
instances: 3
---
name: medium_test
cpu: 0.5
memory: 1024MB
instances: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and refer to them by using:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
scale:
  reference: medium_test 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even cooler and very handy is that you can use VAMP to define automated up and down scaling. It’s very easy. In the deployment definition you simply define a Service Level Agreement (SLA) and an escalation-type. VAMP provides common built-in patterns for this, and our upcoming workflow-engine enables you to easily create your own workflows with a few lines of javascript.&lt;/p&gt;

&lt;p&gt;To setup a basic auto-scaling workflow based on the aggregated response-time of a cluster of containers we simply post the following to a VAMP cluster:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-yaml&#34;&gt;---
 sla:
      # Type of SLA.
      type: response_time_sliding_window
      threshold:
        upper: 1000   # Upper threshold in milliseconds.
        lower: 100    # Lower threshold in milliseconds.
      window:
        interval: 300 # Time period in seconds used for
                      # average response time aggregation.
        cooldown: 600 # Time period in seconds. During this 
                      # period no new escalation events will 
                      # be generated. New event may be expected 
                      # not before cooldown + interval time has 
                      # been reached after the last event. 
     
      # List of escalations.
      escalations:
        - 
          type: scale_instances
          minimum: 1
          maximum: 3
          scale_by: 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will constantly measure the aggregated backend response time of the running cluster of containers, and when the response-time exceeds 1000 milliseconds for over 5 minutes the number of running instances will increase with one (1) until the maximum of three instances is reached. When the response-time becomes lower than 100 milliseconds for over 10 minutes VAMP will make sure the number of instances is scaled down one by one, until the defined minimum of one instance is reached again. VAMP will make sure that new instances are correctly load-balanced, and that removed instances will be correctly drained (of course taking into account sticky sessions and TTL settings).&lt;/p&gt;

&lt;p&gt;VAMP does not only support horizontal scaling as described above, but also vertical scaling (changing memory or CPU scales) and the grouping of multiple escalations, both in sequence or in parallel.&lt;/p&gt;

&lt;h2 id=&#34;getting-started-with-vamp-and-dc-os&#34;&gt;Getting started with VAMP and DC/OS&lt;/h2&gt;

&lt;p&gt;What do I need to do if I want to start experimenting with all these possibilities that VAMP and DC/OS deliver as described in this blog post?&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;First setup a cluster and download and install DC/OS as instructed: &lt;a href=&#34;https://dcos.io/docs/1.7/administration/installing/custom/gui/&#34;&gt;https://dcos.io/docs/1.7/administration/installing/custom/gui/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now install VAMP as a DC/OS package: &lt;a href=&#34;http://vamp.io/documentation/installation/mesosphere_dcos/&#34;&gt;http://vamp.io/documentation/installation/mesosphere_dcos/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Now you can start with our Getting started with VAMP tutorials: &lt;a href=&#34;http://vamp.io/documentation/guides/&#34;&gt;http://vamp.io/documentation/guides/&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&#34;tl-dr-summing-it-up&#34;&gt;TL/DR &amp;amp; Summing it up&lt;/h2&gt;

&lt;p&gt;To make the best use of containers in production environments you need a container cluster manager to deliver resilience and performance. Mesos has an amazing heritage, and all this experience is now packaged into the DC/OS. This gives you an opensource container-cluster solution that is easy to install, battle-hardened, well documented, and solves real world problems by providing an extensive and growing set of solutions and frameworks that run on top of it.&lt;/p&gt;

&lt;p&gt;One of these solutions is VAMP (www.vamp.io) an opensource framework that makes canary-testing/releasing and autoscaling of containers and microservices easy and powerful. Companies like Spotify, Facebook and Booking.com have moved from linear continuous deployment pipelines to continuous improvement feedback-loops using canary-testing&amp;amp;releasing and autoscaling patterns. Canary-testing &amp;amp; releasing is an advanced version of blue-green deployments to avoid downtime when releasing new software.&lt;/p&gt;

&lt;p&gt;When deploying new versions of their software to production they expose these to a small percentage of visitors with specific criteria (a ‘bucket’ or ‘cohort’) to test and validate technical and business performance. When successfully validated they increase the percentage of visitors that land on the new version and at the same time scale-up the number of instances and/or assigned resources to handle the increasing number of visitors with the desired performance-requirements like f.e. response time.&lt;/p&gt;

&lt;p&gt;These canary-test/release and autoscaling patterns require a complex and highly technical coordination and choreography between deploying, load-balancing, metric-aggregation and scaling. Until recently this was only possible to the few companies that could dedicated large amounts of research and development capabilities to this problem.&lt;/p&gt;

&lt;p&gt;VAMP and DC/OS now make it easy to setup and leverage a container-cluster for production-grade environments and start working with containers, microservices and canary-test/release and autoscaling patterns without having to custom-build or understand the underlying technologies.&lt;/p&gt;

&lt;p&gt;Olaf Molenveld
olaf@magnetic.io&lt;/p&gt;
</description>
    </item>
    
    
    
    <item>
      <title>Going native - building native packages for Vamp</title>
      <link>http://vamp.io/2015/08/going-native/</link>
      <pubDate>Wed, 05 Aug 2015 00:00:00 UTC</pubDate>
      
      <guid>http://vamp.io/2015/08/going-native/</guid>
      <description>

&lt;p&gt;To give you a better experience installing Vamp, we decided to create native installers for the most common used platforms.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://vamp.io/img/packaging.png&#34; alt=&#34;&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Okay, we already did the hard part: We designed and created the software, performed the tests, made a zip file, put the zip file on the website and wrote some documentation.&lt;/p&gt;

&lt;p&gt;Only thing you had to do, is download the file, unzip it, put it contents in the correct directory, change the configuration files and write some startup scripts. And repeat these steps for every Vamp module. Easy as eating pie, right?&lt;/p&gt;

&lt;p&gt;We didn&amp;rsquo;t think so either.&lt;/p&gt;

&lt;p&gt;Time to go native.&lt;/p&gt;

&lt;h2 id=&#34;targeting-platforms&#34;&gt;Targeting platforms&lt;/h2&gt;

&lt;p&gt;The Vamp modules will be typically installed on a server, with the exception of Vamp CLI, which is likely to be installed on desktop/laptop environments also. For servers, we&amp;rsquo;ll create native installers for the &lt;a href=&#34;http://www.serverwatch.com/columns/article.php/3900711/The-Top-10-Linux-Server-Distributions.htm&#34;&gt;most widely used Linux flavors&lt;/a&gt;; for the desktop we&amp;rsquo;ll also include OSX, since thats what we are using ourself. And even for the platforms we don&amp;rsquo;t target directly, we can make things a bit easier, by creating a universal install package.&lt;/p&gt;

&lt;h2 id=&#34;sbt-native-packager&#34;&gt;SBT Native Packager&lt;/h2&gt;

&lt;p&gt;Where a Java developer uses Maven, a Scala developer uses SBT as its build system. The SBT ecosystem is quite vibrant and there a some real nice plugins available. One of them is the &lt;a href=&#34;http://www.scala-sbt.org/sbt-native-packager/&#34;&gt;SBT native packager plugin&lt;/a&gt;, which promisses to package your software to run anywhere.&lt;/p&gt;

&lt;p&gt;We created a &lt;a href=&#34;http://github.com/magneticio/vamp-dist&#34;&gt;separate project&lt;/a&gt; for the distribution aspect of Vamp, which contains a directory for each module we want to publish. Out of the box, sbt-native-packager has the ability to create a so called &amp;lsquo;Universal&amp;rsquo; package. This is a zip file in which you&amp;rsquo;ll find a bin directory and a lib directory. To use a universal package, all you have to do is unzip the file and add the bin directory to your PATH statement. That is already a huge improvement.&lt;/p&gt;

&lt;h2 id=&#34;universal-customization&#34;&gt;Universal customization&lt;/h2&gt;

&lt;p&gt;Having a closer look at the Universal package, there are somethings we&amp;rsquo;d like to change.
First of, the contents of the lib directory. It contains all the jar files our application needs, which are quite a few file. Lets change that, by wrapping the files into one single big jar file. With the help of the &lt;a href=&#34;https://github.com/sbt/sbt-assembly&#34;&gt;sbt-assembly&lt;/a&gt; plugin this can be done quite easy, as the excerpt from the CLI   &lt;a href=&#34;https://github.com/magneticio/vamp-dist/blob/master/cli/build.sbt&#34;&gt;build.sbt&lt;/a&gt; file shows:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;//Make a fat jar
assemblyJarName in assembly := &amp;quot;vamp-cli.jar&amp;quot;

// removes all jar mappings in universal and appends the fat jar
mappings in Universal := {
 val universalMappings = (mappings in Universal).value
 val fatJar = (assembly in Compile).value
 // removing means filtering
 val filtered = universalMappings filter {
   case (file, fileName) =&amp;gt;  ! fileName.endsWith(&amp;quot;.jar&amp;quot;)
 }
 // add the fat jar
 filtered :+ (fatJar -&amp;gt; (&amp;quot;lib/&amp;quot; + fatJar.getName))
}

// the bash scripts classpath only needs the fat jar
scriptClasspath := Seq( (assemblyJarName in assembly).value )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second thing we want to change in the CLI package, is the contents of the bin directory. The scripts in the bin directory are automatically generated when the package is being build and there are methods of adding or overriding functionality. For Vamp CLI, we want the name of the executable script to be &lt;code&gt;vamp&lt;/code&gt; instead of &lt;code&gt;vamp-cli&lt;/code&gt; and we&amp;rsquo;d like to include scripting to verify the installed Java version. For this, we had to add some lines to the &lt;a href=&#34;https://github.com/magneticio/vamp-dist/blob/master/cli/build.sbt&#34;&gt;build.sbt&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;executableScriptName := &amp;quot;vamp&amp;quot;

// Add check for Java 8 (not for windows)
bashScriptExtraDefines ++= IO.readLines(baseDirectory.value / &amp;quot;scripts&amp;quot; / &amp;quot;java_check.sh&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;standard-linux&#34;&gt;Standard Linux&lt;/h2&gt;

&lt;p&gt;For Linux, we&amp;rsquo;d like to support Ubtuntu / Debian &amp;amp; Red Hat / CentOS. This means, we need to create .deb and .rpm packages. To do this, we specify some values in the build.sbt, to be included in the package mata information. For .deb packages, we&amp;rsquo;ve added:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;description := &amp;quot;This is the command line interface for VAMP&amp;quot;
packageDescription := &amp;quot;CLI for the Very Awesome Microservices Platform&amp;quot;
packageSummary := &amp;quot;The Vamp CLI&amp;quot;
maintainer :=  &amp;quot;Matthijs Dekker &amp;lt;matthijs@magnetic.io&amp;gt;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the .rpm package, we&amp;rsquo;ve added:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;rpmVendor := &amp;quot;Magnetic.io&amp;quot;
rpmUrl := Some(&amp;quot;http://vamp.io&amp;quot;)
rpmLicense := Some(&amp;quot;Apache 2&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s it. Now we can create Linux packages just by executing the sbt tasks &lt;code&gt;debian:packageBin&lt;/code&gt; and &lt;code&gt;rpm:packageBin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Well not quite &amp;hellip;&lt;/p&gt;

&lt;h2 id=&#34;the-init-problem&#34;&gt;The init problem&lt;/h2&gt;

&lt;p&gt;The .deb package for Vamp CLI was easy to setup, but for our other components, things got a little more complex. The &lt;a href=&#34;http://www.zdnet.com/article/after-linux-civil-war-ubuntu-to-adopt-systemd/&#34;&gt;Linux &amp;lsquo;civil war&amp;rsquo;&lt;/a&gt;, which was all about which system to use for startup and shutdown routines, left a fragmented Linux world. Ubuntu 14.04 LTS uses &lt;code&gt;Upstart&lt;/code&gt;, Debian 7 uses &lt;code&gt;SystemV&lt;/code&gt; and Debian 8 and Ubuntu 15.04 &lt;code&gt;Systemd&lt;/code&gt;. Since we want to support all 4 releases, this means we have to create 3 different .deb packages, one for each init system.&lt;/p&gt;

&lt;p&gt;Luckily, sbt-native-packager has support for all three init systems and by specifying the &lt;code&gt;serverLoading&lt;/code&gt; system, you can tell it which one to use.
For example, to use &lt;code&gt;SystemV&lt;/code&gt; you would use:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;serverLoading in Debian := com.typesafe.sbt.packager.archetypes.ServerLoader.SystemV
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With some SBT trickery, defining a new task &amp;lsquo;packageDebianAll&amp;rsquo;, we can create packages for all three init systems.
For full details, see the &lt;a href=&#34;https://github.com/magneticio/vamp-dist/blob/master/core/build.sbt&#34;&gt;build.sbt&lt;/a&gt; file for Vamp Core.&lt;/p&gt;

&lt;h2 id=&#34;configuration-data&#34;&gt;Configuration &amp;amp; data&lt;/h2&gt;

&lt;p&gt;Our server applications require configuration files and need to write data to disk. By adding &lt;code&gt;mappings&lt;/code&gt;, we can include files into the package.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;mappings in Universal &amp;lt;+= (packageBin in Compile, sourceDirectory ) map { (_, src) =&amp;gt;
  val conf = src / &amp;quot;main&amp;quot; / &amp;quot;resources&amp;quot; / &amp;quot;reference.conf&amp;quot;
  conf -&amp;gt; &amp;quot;conf/application.conf&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will create a &lt;code&gt;conf&lt;/code&gt; directoy in our package, with a file called &lt;code&gt;application.conf&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;To have the configuration file picked up by the startup script, we add it to the &lt;code&gt;bashScriptExtraDefines&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;bashScriptExtraDefines += &amp;quot;&amp;quot;&amp;quot;addJava &amp;quot;-Dconfig.file=${app_home}/../conf/application.conf&amp;quot;&amp;quot;&amp;quot;&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We have configured our application to write data in a &lt;code&gt;data&lt;/code&gt; directory, which we need to create when installing the software:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Add an empty folder to mappings
linuxPackageMappings += packageTemplateMapping(s&amp;quot;/usr/share/${name.value}/data&amp;quot;)() withUser(name.value) withGroup(name.value)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that&amp;rsquo;s it for Vamp.&lt;/p&gt;

&lt;h2 id=&#34;lets-go-all-the-way&#34;&gt;Lets GO all the way&lt;/h2&gt;

&lt;p&gt;One Vamp module got left out, &lt;a href=&#34;https://github.com/magneticio/vamp-router&#34;&gt;Vamp Router&lt;/a&gt;. While the other Vamp modules are all written in Scala, Vamp Router is a &lt;a href=&#34;https://golang.org/&#34;&gt;Go&lt;/a&gt; application and has it&amp;rsquo;s own build process. This build process creates .zip files, based on the hardware platform it can run on. Linux .deb &amp;amp; .rpm packages are however not created by this build, and we came up with a way to use sbt-native-packager for this purpose.&lt;/p&gt;

&lt;p&gt;First, we&amp;rsquo;ll pull the vamp-router zip file from our Bintray download site in a &lt;code&gt;resourceGenerator&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val vampRouterVersion = &amp;quot;0.7.9&amp;quot;

val platform = &amp;quot;amd64&amp;quot;

resourceGenerators in Compile += Def.task {
  val location = url(s&amp;quot;https://bintray.com/artifact/download/magnetic-io/downloads/vamp-router/vamp-router_${vampRouterVersion}_linux_$platform.zip&amp;quot;)
  IO.unzipURL(location, target.value / platform).toSeq
}.taskValue

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next we create mappings, to include the files we&amp;rsquo;ve extracted from the zip file.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// copy vamp-router from the extracted bintray zip
linuxPackageMappings += packageMapping( (target.value / platform / &amp;quot;vamp-router&amp;quot;,  &amp;quot;/usr/share/vamp-router/vamp-router&amp;quot;) ) withPerms &amp;quot;755&amp;quot;

// Add the config files
mappings in Universal &amp;lt;+= (packageBin in Compile, target ) map { (_, target) =&amp;gt;
  val conf = target / platform / &amp;quot;configuration&amp;quot; / &amp;quot;error_pages&amp;quot;  / &amp;quot;500rate.http&amp;quot;
  conf -&amp;gt; &amp;quot;configuration/error_pages/500rate.http&amp;quot;
}

mappings in Universal &amp;lt;+= (packageBin in Compile, target ) map { (_, target) =&amp;gt;
  val conf = target / platform / &amp;quot;configuration&amp;quot; / &amp;quot;templates&amp;quot; / &amp;quot;haproxy_config.template&amp;quot;
  conf -&amp;gt; &amp;quot;configuration/templates/haproxy_config.template&amp;quot;
}

mappings in Universal &amp;lt;+= (packageBin in Compile, target ) map { (_, target) =&amp;gt;
  val conf = target / platform / &amp;quot;examples&amp;quot; / &amp;quot;example1.json&amp;quot;
  conf -&amp;gt; &amp;quot;examples/example1.json&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We add our own start up script, since the generated one would not work for us:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// Add the script file to which starts vamp-router
mappings in Universal &amp;lt;+= (packageBin in Compile, sourceDirectory ) map { (_, src) =&amp;gt;
  val bin = src / &amp;quot;templates&amp;quot; / &amp;quot;bash-template&amp;quot;
  bin -&amp;gt; &amp;quot;bin/vamp-router&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And we remove the generated jar file, since there isn&amp;rsquo;t actually anything in there.&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;// removes all jar mappings in universal
mappings in Universal := {
  val universalMappings = (mappings in Universal).value
  val filtered = universalMappings filter {
    case (file, fileName) =&amp;gt;  ! fileName.endsWith(&amp;quot;.jar&amp;quot;)
  }
  filtered
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the packages we are creating have dependencies and are not architecture independent, we need to add some additional statements to reflect this in the meta data of the packages&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-scala&#34;&gt;val rpmArchitecture=&amp;quot;x86_64&amp;quot;
val debianArchitecture = &amp;quot;amd64&amp;quot;

debianPackageDependencies in Debian ++= Seq(&amp;quot;haproxy&amp;quot;, &amp;quot;bash (&amp;gt;= 2.05a-11)&amp;quot;)
packageArchitecture in Debian := debianArchitecture
debianSection in Debian := &amp;quot;net&amp;quot;

packageArchitecture in Rpm := rpmArchitecture
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this done, we can create packages by running &lt;code&gt;sbt rpm:packageBin&lt;/code&gt; and &lt;code&gt;sbt packageDebianAll&lt;/code&gt;. This will create the debian &lt;code&gt;amd64&lt;/code&gt; and the rpm &lt;code&gt;x86_64&lt;/code&gt; packages. For the Debian &lt;code&gt;i386&lt;/code&gt; packages, we needed to repeat the trick, which we&amp;rsquo;ve done by simple duplicating the whole &lt;a href=&#34;https://github.com/magneticio/vamp-dist/tree/master/router-amd64&#34;&gt;router-amd64&lt;/a&gt; directory.&lt;/p&gt;

&lt;p&gt;And that wraps up all Linux packaging.&lt;/p&gt;

&lt;h2 id=&#34;brewing-our-first-osx-package&#34;&gt;Brewing our first OSX package&lt;/h2&gt;

&lt;p&gt;A popular method of installing software on OSX is using &lt;a href=&#34;http://brew.sh/&#34;&gt;homebrew&lt;/a&gt;. It allows you to install software from the command line, without the hassle of the Apple App Store. Creating a &lt;code&gt;brew&lt;/code&gt; package is not that hard. We setup an additional github repository, &lt;a href=&#34;https://github.com/magneticio/homebrew-vamp&#34;&gt;homebrew-vamp&lt;/a&gt;, here we could store our &lt;code&gt;formula&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Our forumula uses the Vamp CLI Universal package as a basis. For the brew package, we add an &lt;a href=&#34;https://github.com/magneticio/vamp-dist/blob/master/cli/src/scripts/brew_vamp&#34;&gt;additional script&lt;/a&gt; to the Universal package&lt;/p&gt;

&lt;p&gt;The complete formula is just a couple of lines of Ruby&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-ruby&#34;&gt;require &amp;quot;formula&amp;quot;

class Vamp &amp;lt; Formula
  homepage &amp;quot;http://vamp.io&amp;quot;
  version &amp;quot;0.7.9&amp;quot;
  url &amp;quot;https://bintray.com/artifact/download/magnetic-io/downloads/vamp-cli/vamp-cli-#{version}.zip&amp;quot;
  # generate the sha256 hash on your mac with the command: shasum -a 256 &amp;lt;filename&amp;gt;
  sha256 &amp;quot;c6385ceff1200c1f990bf133f5189270eca4a174ceedacb4a8e9915eda3b02ca&amp;quot;

  def install
      inreplace &amp;quot;brew/vamp&amp;quot;, &amp;quot;##PREFIX##&amp;quot;, &amp;quot;#{prefix}&amp;quot;
      prefix.install &amp;quot;lib/vamp-cli.jar&amp;quot;
      bin.install &amp;quot;brew/vamp&amp;quot;
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we release a new version of Vamp, we need to update our formula, with the latest version number and an updated sha256 hash.&lt;/p&gt;

&lt;h2 id=&#34;fire-and-forget&#34;&gt;Fire and forget&lt;/h2&gt;

&lt;p&gt;With everything setup to create packages, the next step was automating it, so we can publish all packages with the push of a button. For every release, we update the version number the build.sbt files and update the library dependencies. Once, we push these changes to &lt;a href=&#34;https://github.com/magneticio/vamp-dist&#34;&gt;Github&lt;/a&gt;, Travis CI will start building the packages and with the help of some custom bash scripts, push it all to &lt;a href=&#34;https://bintray.com/magnetic-io/&#34;&gt;Bintray&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;The final step is to update the brew formula on Github and we&amp;rsquo;ve done another release!&lt;/p&gt;
</description>
    </item>
    
    
  </channel>
</rss>